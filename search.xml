<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS_02</title>
      <link href="/2022/11/12/FreeRTOS-02/"/>
      <url>/2022/11/12/FreeRTOS-02/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：FreeRTOS的移植以及做基本的使用"><a href="#第二章：FreeRTOS的移植以及做基本的使用" class="headerlink" title="第二章：FreeRTOS的移植以及做基本的使用"></a>第二章：FreeRTOS的移植以及做基本的使用</h1><p>本节课我们将会带着大家进行我们的FreeRTOS的移植，本节课主要是实际操作，而且刚开始学习的话，暂时不用过于纠结原理，FreeRTOS只是一个使用的工具我们应该学习的是如何去使用，就像学习我们的STM32一样，先把项目建立出来，让我们LED亮起来再去研究原理和代码</p><h2 id="壹：FreeRTOS的手动移植"><a href="#壹：FreeRTOS的手动移植" class="headerlink" title="壹：FreeRTOS的手动移植"></a><strong>壹：FreeRTOS的手动移植</strong></h2><p>这里我们将会教大家 如何进行我们手动的项目移植</p><h3 id="①-建立STM32的空项目"><a href="#①-建立STM32的空项目" class="headerlink" title="①.建立STM32的空项目"></a>①.建立STM32的空项目</h3><p>这里使用STM32CubeMX快速创建项目，要注意的是我们完成最基本的配置以后，需要将我们的Timebase Source修改一下，修改成除了滴答滴答定时器的其他定时器，就像这样</p><p><img src="/img/blog/image-20220807234427467.png" alt="image-20220807234427467"></p><p>这里我使用的TIM2作为Timebase Source</p><h4 id="为什么不可以使用滴答定时器呢？"><a href="#为什么不可以使用滴答定时器呢？" class="headerlink" title="|为什么不可以使用滴答定时器呢？"></a>|<strong>为什么不可以使用滴答定时器呢？</strong></h4><p>在FreeRTOS中我们的SysTick定时器被用于了我们的始终基准，它用来实现我们的仍无切换，我们的SysTick定时器每次触发我们的中断（默认是一毫秒，可以自行修改为其他值）</p><h4 id="Timebase-Source是干嘛的呢？"><a href="#Timebase-Source是干嘛的呢？" class="headerlink" title="|Timebase Source是干嘛的呢？"></a>|Timebase Source是干嘛的呢？</h4><p>简单的说，正常裸机开发中我们的SysTick定时器是用来主要是用来进行我们的HAL_Delay()延时的，使用其作为基准，前面我们说了SysTick定时器被用于系统任务切换了，所以它就是一直在工作，或者说一直在触发中断，这样的话我们的HAL_Delay()就需用使用我们的其他定时器进行替代其作用了</p><p>为了方便移植展示，这里就生成一个Keil的项目吧！</p><h3 id="②-FreeRTOS内核下载"><a href="#②-FreeRTOS内核下载" class="headerlink" title="②.FreeRTOS内核下载"></a>②.FreeRTOS内核下载</h3><p>以我们自己的能力肯定是不可能自己写出来操作系统的，这一步将会教大家如何去下载FreeRTOS内核以及如何进行移植到我们的项目里面</p><h4 id="进入FreeRTOS的官网"><a href="#进入FreeRTOS的官网" class="headerlink" title="|进入FreeRTOS的官网"></a>|进入FreeRTOS的官网</h4><p>可以选择百度直接搜索FreeRTOS</p><p><img src="/img/blog/image-20220808155909183.png" alt="image-20220808155909183"></p><p>然后选择</p><p><img src="/img/blog/image-20220808155935717.png" alt="image-20220808155935717"></p><p>也可以直接点击该链接进入</p><p><a href="https://www.freertos.org/">https://www.freertos.org/</a></p><p>然后点击右上角下载FreeRTOS</p><p><img src="/img/blog/image-20220808160040097.png" alt="image-20220808160040097"></p><p>来到版本选择界面</p><p><img src="/img/blog/image-20220808160125937.png" alt="image-20220808160125937"></p><p>上面的是FreeRTOS的最新版本，下面的就是长期维护的版本</p><p>我们直接点击上面这个Github的超链接</p><p><img src="/img/blog/image-20220808161616625.png" alt="image-20220808161616625"></p><p>然后就依次带点击Code和Download ZIP</p><p><img src="/img/blog/image-20220808161844246.png" alt="image-20220808161844246"></p><p>不过我发现，这个下载下来好像是不完整的</p><p><img src="/img/blog/image-20220808161954743.png" alt="image-20220808161954743"></p><p>这里也写了它的子模块是不会直接下载进去的，这里我们就需要继续往下翻</p><p><img src="/img/blog/image-20220808162132172.png" alt="image-20220808162132172"></p><p>翻译过来就是这样的</p><p><img src="/img/blog/image-20220808162148237.png" alt="image-20220808162148237"></p><p>内核代码在这里我们点击超链接，同样的方法进行下载</p><p>这里就快速掠过，如果无法下载应该就是网络问题了</p><p>下载好，然后进行一下解压</p><p><img src="/img/blog/image-20220808174843292.png" alt="image-20220808174843292"></p><p>解压好了就是这个样子</p><p>FreeRTOS-Kernel是FreeRTOS的内核文件</p><p>FreeRTOS-main里面文件很多，我们主要是看里面的Demo</p><p><img src="/img/blog/image-20220808175037048.png" alt="image-20220808175037048"></p><p>然后接着点击<img src="/img/blog/image-20220808175057051.png" alt="image-20220808175057051"></p><p>里面的文件非常多，不过我们可以找到这样一个文件夹</p><p><img src="/img/blog/image-20220808175154467.png" alt="image-20220808175154467"></p><p>这里有系统已经移植好的实例，但是这并不是我们直接移植的，感兴趣的小伙伴可以先打看官方移植好的能不能看懂</p><h3 id="③-手动移植FreeRTOS内核文件"><a href="#③-手动移植FreeRTOS内核文件" class="headerlink" title="③.手动移植FreeRTOS内核文件"></a>③.手动移植FreeRTOS内核文件</h3><h4 id="1-打开第一步建立的新项目"><a href="#1-打开第一步建立的新项目" class="headerlink" title="1.打开第一步建立的新项目"></a>1.打开第一步建立的新项目</h4><h4 id="2-左侧项目文件添加两个新的分组"><a href="#2-左侧项目文件添加两个新的分组" class="headerlink" title="2.左侧项目文件添加两个新的分组"></a>2.左侧项目文件添加两个新的分组</h4><p><img src="/img/blog/image-20220808180601576.png" alt="image-20220808180601576"></p><h4 id="3-建立对应的FreeRTOS文件夹"><a href="#3-建立对应的FreeRTOS文件夹" class="headerlink" title="3.建立对应的FreeRTOS文件夹"></a>3.建立对应的FreeRTOS文件夹</h4><p><img src="/img/blog/image-20220808181508665.png" alt="image-20220808181508665"></p><h4 id="4-打开FreeRTOS-Kernel文件夹"><a href="#4-打开FreeRTOS-Kernel文件夹" class="headerlink" title="4.打开FreeRTOS-Kernel文件夹"></a>4.打开FreeRTOS-Kernel文件夹</h4><h4 id="5-主目录下所有的-C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）"><a href="#5-主目录下所有的-C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）" class="headerlink" title="5.主目录下所有的.C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）"></a>5.主目录下所有的.C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）</h4><p><img src="/img/blog/image-20220808181613953.png" alt="image-20220808181613953"></p><h4 id="6-复制include文件夹以及portable文件夹到FreeRTOS文件夹下"><a href="#6-复制include文件夹以及portable文件夹到FreeRTOS文件夹下" class="headerlink" title="6.复制include文件夹以及portable文件夹到FreeRTOS文件夹下"></a>6.复制include文件夹以及portable文件夹到FreeRTOS文件夹下</h4><p><img src="/img/blog/image-20220808181838922.png" alt="image-20220808181838922"></p><h4 id="7-保留FreeRTOS-x2F-portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除"><a href="#7-保留FreeRTOS-x2F-portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除" class="headerlink" title="7.保留FreeRTOS&#x2F;portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除"></a>7.保留FreeRTOS&#x2F;portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除</h4><p><img src="/img/blog/image-20220808182219502.png" alt="image-20220808182219502"></p><h4 id="8-保留FreeRTOS-x2F-portable-x2F-RVDS文件夹中的ARM-CM3文件夹"><a href="#8-保留FreeRTOS-x2F-portable-x2F-RVDS文件夹中的ARM-CM3文件夹" class="headerlink" title="8.保留FreeRTOS&#x2F;portable&#x2F;RVDS文件夹中的ARM_CM3文件夹"></a>8.保留FreeRTOS&#x2F;portable&#x2F;RVDS文件夹中的ARM_CM3文件夹</h4><p><img src="/img/blog/image-20220808182339598.png" alt="image-20220808182339598"></p><h4 id="9-然后如图进行Keil项目的分组文件配置"><a href="#9-然后如图进行Keil项目的分组文件配置" class="headerlink" title="9.然后如图进行Keil项目的分组文件配置"></a>9.然后如图进行Keil项目的分组文件配置</h4><p><img src="/img/blog/image-20220808182506735.png" alt="image-20220808182506735"></p><p><img src="/img/blog/image-20220808182619420.png" alt="image-20220808182619420"></p><h4 id="10-添加对应的头文件"><a href="#10-添加对应的头文件" class="headerlink" title="10.添加对应的头文件"></a>10.添加对应的头文件</h4><p><img src="/img/blog/image-20220808182744742.png" alt="image-20220808182744742"></p><h4 id="11-直接编译（出现9个错误）"><a href="#11-直接编译（出现9个错误）" class="headerlink" title="11.直接编译（出现9个错误）"></a>11.直接编译（出现9个错误）</h4><p><img src="/img/blog/image-20220808183013851.png" alt="image-20220808183013851"></p><h3 id="④-项目问题修复"><a href="#④-项目问题修复" class="headerlink" title="④.项目问题修复"></a>④.项目问题修复</h3><h4 id="缺少FreeRTOSConfig-h文件（FreeRTOS的配置文件）"><a href="#缺少FreeRTOSConfig-h文件（FreeRTOS的配置文件）" class="headerlink" title="|缺少FreeRTOSConfig.h文件（FreeRTOS的配置文件）"></a>|缺少FreeRTOSConfig.h文件（FreeRTOS的配置文件）</h4><p><img src="/img/blog/image-20220808183724419.png" alt="image-20220808183724419"></p><h4 id="示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）"><a href="#示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）" class="headerlink" title="|示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）"></a>|示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）</h4><p><img src="/img/blog/image-20220808183808327.png" alt="image-20220808183808327"></p><p><img src="/img/blog/image-20220808183927543.png" alt="image-20220808183927543"></p><h4 id="编译，还是报错"><a href="#编译，还是报错" class="headerlink" title="|编译，还是报错"></a>|编译，还是报错</h4><p><img src="/img/blog/image-20220808184017777.png" alt="image-20220808184017777"></p><h4 id="在FreeRTOSConfig-h中添加-defineINCLUDE-xTaskGetCurrentTaskHandle1"><a href="#在FreeRTOSConfig-h中添加-defineINCLUDE-xTaskGetCurrentTaskHandle1" class="headerlink" title="|在FreeRTOSConfig.h中添加#defineINCLUDE_xTaskGetCurrentTaskHandle1"></a>|在FreeRTOSConfig.h中添加#defineINCLUDE_xTaskGetCurrentTaskHandle1</h4><h4 id="编译无错误"><a href="#编译无错误" class="headerlink" title="|编译无错误"></a>|编译无错误</h4><p><img src="/img/blog/image-20220808191109640.png" alt="image-20220808191109640"></p><h3 id="⑤-项目添加处理"><a href="#⑤-项目添加处理" class="headerlink" title="⑤.项目添加处理"></a>⑤.项目添加处理</h3><p>虽然没有错误了，但是我们的移植没有完成，还有一些小步骤需要完成，的确有些繁琐，好在逻辑性还是比较强的，理解起来相对容易</p><h4 id="在FreeRTOSConfig-h中添加-definexPortPendSVHandlerPendSV-Handler"><a href="#在FreeRTOSConfig-h中添加-definexPortPendSVHandlerPendSV-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definexPortPendSVHandlerPendSV_Handler"></a>|在FreeRTOSConfig.h中添加#definexPortPendSVHandlerPendSV_Handler</h4><h4 id="在FreeRTOSConfig-h中添加-definexPortSysTickHandlerSysTick-Handler"><a href="#在FreeRTOSConfig-h中添加-definexPortSysTickHandlerSysTick-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definexPortSysTickHandlerSysTick_Handler"></a>|在FreeRTOSConfig.h中添加#definexPortSysTickHandlerSysTick_Handler</h4><h4 id="在FreeRTOSConfig-h中添加-definevPortSVCHandlerSVC-Handler"><a href="#在FreeRTOSConfig-h中添加-definevPortSVCHandlerSVC-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definevPortSVCHandlerSVC_Handler"></a>|在FreeRTOSConfig.h中添加#definevPortSVCHandlerSVC_Handler</h4><p>左边三个是我们Free RTOS中定义好的函数，右边的是系统项目本来就定义好的函数，他们的作用小伙伴们可以去了解一下，作为初学者这里不进行拓展，反正就是和我们操作系统的中断还有任务切换有关的函数</p><h4 id="编译，还是报错，重复定义"><a href="#编译，还是报错，重复定义" class="headerlink" title="|编译，还是报错，重复定义"></a>|编译，还是报错，重复定义</h4><p><img src="/img/blog/image-20220808193114683.png" alt="image-20220808193114683"></p><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="|处理错误"></a>|处理错误</h4><h4 id="进入对应的文件stm32f1xx-it-c删除重复的3个函数"><a href="#进入对应的文件stm32f1xx-it-c删除重复的3个函数" class="headerlink" title="|进入对应的文件stm32f1xx_it.c删除重复的3个函数"></a>|进入对应的文件stm32f1xx_it.c删除重复的3个函数</h4><h4 id="OK啦！"><a href="#OK啦！" class="headerlink" title="|OK啦！"></a>|OK啦！</h4><h3 id="⑥-FreeRTOS点灯项目创建"><a href="#⑥-FreeRTOS点灯项目创建" class="headerlink" title="⑥.FreeRTOS点灯项目创建"></a>⑥.FreeRTOS点灯项目创建</h3><p>弄了这么久，终于移植完成了，我们现在开始创建我们的任务吧！</p><p>首先回到项目中我们需要</p><h4 id="相关的头文件引入"><a href="#相关的头文件引入" class="headerlink" title="相关的头文件引入"></a><strong>相关的头文件引入</strong></h4><p>用到的头文件有<br>“FreeRTOS.h”（操作系统相关）</p><p>“task.h”（任务相关）</p><p><img src="/img/blog/image-20220808205027644.png" alt="image-20220808205027644"></p><h4 id="任务函数创建"><a href="#任务函数创建" class="headerlink" title="任务函数创建"></a><strong>任务函数创建</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,<span class="number">0</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,<span class="number">1</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,<span class="number">0</span>);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,<span class="number">1</span>);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主函数创建任务，以及开启任务调度器"><a href="#主函数创建任务，以及开启任务调度器" class="headerlink" title="主函数创建任务，以及开启任务调度器"></a><strong>主函数创建任务，以及开启任务调度器</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    <span class="comment">//创建任务1</span></span><br><span class="line">xTaskCreate(vTask1,<span class="string">&quot;LED1&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建任务2</span></span><br><span class="line">xTaskCreate(vTask2,<span class="string">&quot;LED2&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//启动任务调度器</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦-程序烧录到开发板查看效果"><a href="#⑦-程序烧录到开发板查看效果" class="headerlink" title="⑦.程序烧录到开发板查看效果"></a>⑦.程序烧录到开发板查看效果</h3><p>编译项目，然后进行简单的烧录，并且查看效果</p><h2 id="贰：CubeMX快速生成FreeRTOS项目"><a href="#贰：CubeMX快速生成FreeRTOS项目" class="headerlink" title="贰：CubeMX快速生成FreeRTOS项目"></a><strong>贰：CubeMX快速生成FreeRTOS项目</strong></h2><p>前面我们已经成功手动移植了我们的FreeRTOS的操作系统，步骤相对来说还是比较繁琐的，在我们的开发中肯定不可能每次都去这样的移植，所以我们本期视频就是教大家一个更快捷高效的方法，也就是使用我们的CubeMX快速生产FreeRTOS的项目，并且达到我们上期视频同样的效果，好了我们现在开始，这里我将会使用CubeIDE来生成项目</p><h3 id="①正常流程初始化项目"><a href="#①正常流程初始化项目" class="headerlink" title="①正常流程初始化项目"></a>①正常流程初始化项目</h3><p>我们就按照平常初始化项目，把我们的时钟频率设置好以及我们上节课讲到了基本时钟源改为其他的定时器</p><p><img src="/img/blog/image-20220809090154611.png" alt="image-20220809090154611"></p><p><img src="/img/blog/image-20220809090213133.png" alt="image-20220809090213133"></p><h3 id="②找到Middleware选项然后点击FREERTOS"><a href="#②找到Middleware选项然后点击FREERTOS" class="headerlink" title="②找到Middleware选项然后点击FREERTOS"></a>②找到Middleware选项然后点击FREERTOS</h3><p><img src="/img/blog/image-20220809090351242.png" alt="image-20220809090351242"></p><h3 id="③选择CMSIS-V1"><a href="#③选择CMSIS-V1" class="headerlink" title="③选择CMSIS_V1"></a>③选择CMSIS_V1</h3><h4 id="版本解释"><a href="#版本解释" class="headerlink" title="版本解释"></a>版本解释</h4><p>V1的这个版本是老版本，然后V2版本是新版本，其实区别没有很大版本也没有差很多，不过相对来说我们直接选择V1就可以了，因为使用的人是比较多的</p><h3 id="④参数介绍"><a href="#④参数介绍" class="headerlink" title="④参数介绍"></a>④参数介绍</h3><p><img src="/img/blog/image-20220809090701721.png" alt="image-20220809090701721"></p><p>可以看到我们需要设置的参数是非常非常多的，这里阿熊就给大家简单的解释一些常用的后续碰到会陆续的进行解释</p><h4 id="Config-parameters（配置参数）"><a href="#Config-parameters（配置参数）" class="headerlink" title="Config parameters（配置参数）"></a>Config parameters（配置参数）</h4><p><img src="/img/blog/image-20220809090918763.png" alt="image-20220809090918763"></p><p>这里就是我们Free RTOS的配置参数，可以选择性的开启或者关闭某些功能，我们前面有讲过FreeRTOS的可裁剪性，是它的一大优势，像我们的这些设置里就是开启或关闭它的一些功能</p><h4 id="Include-parameters（内部参数）"><a href="#Include-parameters（内部参数）" class="headerlink" title="Include parameters（内部参数）"></a>Include parameters（内部参数）</h4><p><img src="/img/blog/image-20220809091219415.png" alt="image-20220809091219415"></p><p>这里面是我们开发中可能会用到的一些函数，我们如果用不到的话可以就选择性的将其关闭，这样的话我们的内核大小也会减小很多</p><h4 id="Tasks-and-Queues（任务和队列）"><a href="#Tasks-and-Queues（任务和队列）" class="headerlink" title="Tasks and Queues（任务和队列）"></a>Tasks and Queues（任务和队列）</h4><p><img src="/img/blog/image-20220809091405056.png" alt="image-20220809091405056"></p><p>我们操作系统中的任务还有我们的队列（后续会介绍到）都是可以直接在这里进行一个初始化的，我们只需要去更新内部的函数内容就可以高效的完成我们的项目</p><h4 id="Other（其他设置）"><a href="#Other（其他设置）" class="headerlink" title="Other（其他设置）"></a>Other（其他设置）</h4><p>这里我们就只介绍我们的这3个比较重要的，其他的全部统称为其他设置，后续的课程中，我们遇到了再讲解</p><h3 id="⑤添加Task"><a href="#⑤添加Task" class="headerlink" title="⑤添加Task"></a>⑤添加Task</h3><p>直接点击Add或者双击默认的项目</p><p><img src="/img/blog/image-20220809091752257.png" alt="image-20220809091752257"></p><p>其分别对应</p><p>任务名称、任务优先级、任务堆栈大小、进入函数名称、代码生成方式、参数、任务类型</p><h4 id="任务名称："><a href="#任务名称：" class="headerlink" title="任务名称："></a>任务名称：</h4><p>就是单纯的名称，一般随便取一个就好了，没有什么实质性的作用，毕竟我们执行的时候用的是函数名称</p><h4 id="任务优先级："><a href="#任务优先级：" class="headerlink" title="任务优先级："></a>任务优先级：</h4><p>任务优先级就很像我们那个中断优先级，不过它与我们的中断优先级是相反的，我们的中断优先级中的中段是数字越小，然后它的优先级就会越高，我们的操作系统中数字越大，优先级越高，并且会优先执行</p><h4 id="任务堆栈大小："><a href="#任务堆栈大小：" class="headerlink" title="任务堆栈大小："></a>任务堆栈大小：</h4><p>就是可以理解为我们的任务执行所需要的空间大小，太大了不是很好，太小了反而会不够，所以这个需要一定的经验去判断</p><h4 id="进入函数名称："><a href="#进入函数名称：" class="headerlink" title="进入函数名称："></a>进入函数名称：</h4><p>就是我们执行任务时对应的那个函数，它的名称是什么？我们的系统会自动给我们写好一个框架</p><h4 id="任务类型："><a href="#任务类型：" class="headerlink" title="任务类型："></a>任务类型：</h4><p>我们任务生成的类型有动态生成，还有静态生成，动态生成的话就是系统，你只要告诉他空间大小系统会自己划分好，而我们静态生成是直接要指定一块地点，相对来说使用是非常少的，而且作为初学者几乎是完全理解不了的，所以我们本视频系列教程是不会涉及到静态生成任务，只会讲解动态任务</p><h4 id="Other："><a href="#Other：" class="headerlink" title="Other："></a>Other：</h4><p>前面就是我们需要理解的，其他的我们后续遇到了会再讲解</p><h4 id="添加LED的任务："><a href="#添加LED的任务：" class="headerlink" title="添加LED的任务："></a>添加LED的任务：</h4><p><img src="/img/blog/image-20220809092814718.png" alt="image-20220809092814718"></p><p><img src="/img/blog/image-20220809092900372.png" alt="image-20220809092900372"></p><h4 id="保存一下，然后生成项目"><a href="#保存一下，然后生成项目" class="headerlink" title="保存一下，然后生成项目"></a>保存一下，然后生成项目</h4><h3 id="⑥完成任务函数"><a href="#⑥完成任务函数" class="headerlink" title="⑥完成任务函数"></a>⑥完成任务函数</h3><p>可以看到我们生成的项目中，main.C中他并没有那个任务的函数，我们可以找到左边的那个文件管理来，可以找到一个freeRTOS.C的项目文件，然后我们双击打开</p><p><img src="/img/blog/image-20220809093230591.png" alt="image-20220809093230591"></p><p>然后我们就可以快速的完成一下两个任务，上节课视频我们也有讲过，如何去书写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header_LED_Task1 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Function implementing the LED1 thread.</span></span><br><span class="line"><span class="comment">  * @param  argument: Not used</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_LED_Task1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED_Task1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,<span class="number">1</span>);</span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,<span class="number">0</span>);</span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED_Task1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Header_LED_Task2 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Function implementing the LED2 thread.</span></span><br><span class="line"><span class="comment">* @param argument: Not used</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_LED_Task2 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED_Task2 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin,<span class="number">1</span>);</span><br><span class="line">  HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin,<span class="number">0</span>);</span><br><span class="line">  HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED_Task2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦编译，烧录查看现象"><a href="#⑦编译，烧录查看现象" class="headerlink" title="⑦编译，烧录查看现象"></a>⑦编译，烧录查看现象</h3><p>可以看到我们的那个实验现象和上期手动移植的现象是完全一样的，我们成功完成了快速生成FreeRTOS的项目并且完成了最基本的任务</p><h3 id="⑧代码讲解"><a href="#⑧代码讲解" class="headerlink" title="⑧代码讲解"></a>⑧代码讲解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* Call init function for freertos objects (in freertos.c) */</span></span><br><span class="line">  MX_FREERTOS_Init();</span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="comment">/* We should never get here as control is now taken by the scheduler */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数中，我们最开始还是普通的初始化，和我们的普通项目没有区别</p><p>接着是</p><p>MX_FREERTOS_Init();</p><p>我们转跳过去看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Create the thread(s) */</span></span><br><span class="line">  <span class="comment">/* definition and creation of LED1 */</span></span><br><span class="line">  osThreadDef(LED1, LED_Task1, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED1Handle = osThreadCreate(osThread(LED1), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* definition and creation of LED2 */</span></span><br><span class="line">  osThreadDef(LED2, LED_Task2, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED2Handle = osThreadCreate(osThread(LED2), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容也很简单，其实他就是创建了我们的两个项目，然后相对来说小伙伴们可以发现和我们手动一直是不一样的，因为我们的 Free rtos的那个操作系统在我们那个ST官方的那个优化下，他自己将很多函数都进行了重新的宏定义以及方法的改写</p><p>我们甚至可以转跳过去看看他是怎么实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">osThreadId <span class="title function_">osThreadCreate</span> <span class="params">(<span class="type">const</span> osThreadDef_t *thread_def, <span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TaskHandle_t handle;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line">  <span class="keyword">if</span>((thread_def-&gt;buffer != <span class="literal">NULL</span>) &amp;&amp; (thread_def-&gt;controlblock != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              thread_def-&gt;buffer, thread_def-&gt;controlblock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              &amp;handle) != pdPASS)  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span>( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line"></span><br><span class="line">    handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              thread_def-&gt;buffer, thread_def-&gt;controlblock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">                   thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">                   &amp;handle) != pdPASS)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然他看起来很复杂，但是我们几乎可以一眼就找到我们上节课用到的那个xTaskCreate函数</p><p>在我们系统生成的FreeRTOS的框架下，它是宏定义了很多的函数，但其实用法师和我们的没有什么区别，我们甚至可以直接用我们上节课所写的那些东西,也可以实现同样的效果</p><p>这里就不拓展开了，碰到了我们再讲解</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_01</title>
      <link href="/2022/11/12/FreeRTOS-01/"/>
      <url>/2022/11/12/FreeRTOS-01/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：FreeRTOS的简述"><a href="#第一章：FreeRTOS的简述" class="headerlink" title="第一章：FreeRTOS的简述"></a>第一章：FreeRTOS的简述</h1><p>说到FreeRTOS，就不得不先带着大家去了解一下我们的RTOS</p><h2 id="壹：RTOS的简介"><a href="#壹：RTOS的简介" class="headerlink" title="壹：RTOS的简介"></a><strong>壹：RTOS的简介</strong></h2><p>实时操作系统（Real Time Operating System，简称RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点</p><p><a href="https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/357530?fromtitle=RTOS&amp;fromid=987080&amp;fr=aladdin">https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/357530?fromtitle=RTOS&amp;fromid=987080&amp;fr=aladdin</a></p><p>这里有转跳链接，小伙伴们可以转跳过去仔细看看，这里就不过多的赘述，简单的总结如下：</p><p>大体上，实时操作系统（RTOS）要求：</p><ul><li>多任务</li><li>处理能被区分优先次序的进程线</li><li>一个中断水平的充分数量</li></ul><p>被装入作为微型设备一部分的内含小操作系统经常要求实时操作系统。一些核心问题能被考虑以符合实时操作系统的需求。然而，因为像设备驱动程序这样的其他成份，也通常被特别的方法需要，一个实时操作系统通常比核心更大</p><p>RTOS只是一个统称，他可以分为各种各样的版本以及平台，由于RTOS需占用一定的系统资源(尤其是RAM资源)，只有μC&#x2F;OS-II、embOS、salvo、FreeRTOS等少数能在小RAM单片机上运行。相对μC&#x2F;OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行</p><p>然后我们现在来看我们的FreeRTOS</p><h2 id="贰：FreeRTOS的简介"><a href="#贰：FreeRTOS的简介" class="headerlink" title="贰：FreeRTOS的简介"></a><strong>贰：FreeRTOS的简介</strong></h2><p>FreeRTOS是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要</p><p>其功能特点如下：</p><ul><li><strong>用户可配置内核功能(可裁剪)</strong></li><li><strong>多平台的支持</strong></li><li><strong>提供一个高层次的信任代码的完整性</strong></li><li><strong>目标代码小，简单易用</strong></li><li><strong>遵循MISRA-C标准的编程规范</strong></li><li><strong>强大的执行跟踪功能</strong></li><li><strong>堆栈溢出检测</strong></li><li><strong>没有限制的任务数量</strong></li><li><strong>没有限制的任务优先级</strong></li><li><strong>多个任务可以分配相同的优先权</strong></li><li><strong>队列，二进制信号量，计数信号灯和递归通信和同步的任务</strong></li><li><strong>优先级继承</strong></li><li><strong>免费开源的源代码</strong></li></ul><p>并且最重要的一点是支持免费的商用，而且社区环境很好，使用的人很多</p><p><strong>这里有转跳链接，小伙伴们可以转跳过去仔细看看</strong></p><p><a href="https://baike.baidu.com/item/FreeRTOS/9786143?fr=aladdin">https://baike.baidu.com/item/FreeRTOS/9786143?fr=aladdin</a></p><h2 id="叁：多任务操作系统的引入"><a href="#叁：多任务操作系统的引入" class="headerlink" title="叁：多任务操作系统的引入"></a>叁：多任务操作系统的引入</h2><p>说到多任务操作系统，我们就不得不提到我们的裸机开发，裸机开发的话，它并不是相对于多任务操作系统就很弱，他们俩在各自的领域有各自的使用场景，也有各自的优缺点，就比如说我们直接进行裸机开发，它主要是在我们的一个while循环中进行所有的项目操作，有些情况下，会有一个或者多个中断来处理一些突然发生的事或者已经设计好的事情，如果我们仅仅是开发一些小项目或者功能比较单一的项目，裸机是最可靠最有效而且很方便开发的一种模式，但是当我们的项目功能越来越多，我们就要引入多任务的操作系统，多任务操作系统顾名思义就是可以处理很多个任务，就像我们的手机一样，我们的手机后台也是可以挂起多个应用的</p><p>在我们引入操作系统之后，我们就不需要去精心的设计我们的时序流程，因为各个任务之间是不存在相互干扰的，我们只需要使用我们的命令去开启或者关闭某一些任务就可以了，当然这肯定是需要占用一些系统资源的，不过现在的单片机的内存都是足够大的，所以我们一般情况下是不需要担心我们的操作系统内核，而是直接移植进行使用，并且我们的多任务操作系统的思维，就很像我们人去思考的思维更加的方便，而我们的裸机开发更像是机械思维，在开发过程中以及开发流程中操作系统是非常方便使用以及开发的</p><p>我们可以再通俗一点的讲，把我们的单片机当做一台电脑的CPU，就像我们使用的电脑一样，我们在上面安装了windows系统，而我们需要执行的任务，比如说打开QQ或者其他的任务，只需要在操作系统上进行完成就可以了</p><p>说了这么多，相信小伙伴们还是对实际的多任务操作系统还是没什么概念，这里就简单给大家举一个例子</p><p>这里并不会出现源码，只是大概的体现一下RTOS与裸机开发的不同之处</p><p>裸机开发中LED闪烁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    whlie(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LED1置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED1置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是只有一个LED的情况如果有两个LED，一个需要500MS闪烁，一个需要一秒闪烁一次，这样的话我们的代码是不是难度就加大了,好像逻辑就混乱了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    whlie(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LED1置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED1置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED2置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时500MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时500MS</span></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们大脑最希望的添加代码方式，很显然他是错的，两个任务之间产生了相互的影响，使得两个任务都执行错误，很多同学就会说这是阿熊代码的问题，对没错，这种思想在裸机开发中肯定是错的，但是在我们的RTOS中他就可以是对的</p><p><img src="/img/blog/image-20220807151229878.png" alt="1"></p><p>这是我们独立的两个任务内容，我们只需要把他的扔到我们的任务执行器里，他就会“同时”运行了，很多小伙伴就会疑问了，单片机明明只有一个核，为什么可以同时执行多个任务呢？</p><h2 id="肆：任务“同时”执行的原理"><a href="#肆：任务“同时”执行的原理" class="headerlink" title="肆：任务“同时”执行的原理"></a>肆：任务“同时”执行的原理</h2><p>还记得我们51单片机里面讲的8*8LED的点阵吗？</p><p><img src="/img/blog/image-20220807151850554.png" alt="2">)</p><p>就这家伙，还记得他是怎么做到使用16个引脚驱动64个灯的吗？</p><p>视觉暂停，也可以说是“视觉欺骗”，他并不是同时亮起来的，而是一排一排亮起来的，只不过切换的速度太快了，肉眼反应不过来，所以就同时亮起来了</p><p>我们RTOS也差不多是这样，我们可以让我们的每个任务执行一个时间单位，然后就切换到另外一个任务执行一个时间单位，再切换回去，两个任务都是独立运行的，互不影响，由于切换的频率很快，就感觉像是同时运行的一样</p><p><img src="/img/blog/image-20220807161019652.png" alt="3"></p><h1 id="这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮"><a href="#这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮" class="headerlink" title="这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮"></a>这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮</h1><hr>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/06/hello-world/"/>
      <url>/2022/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
