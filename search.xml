<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS_11</title>
      <link href="/2022/11/12/FreeRTOS-11/"/>
      <url>/2022/11/12/FreeRTOS-11/</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章：软件定时器"><a href="#第十一章：软件定时器" class="headerlink" title="第十一章：软件定时器"></a>第十一章：软件定时器</h1><p>顾名思义就是通过我们软件去实现我们的定时器功能，有时候我们的单片机它的内部硬件定时器资源并不是很多，然后我们FreeRTOS就给我们提供了现成的软件定时器，可以一定程度上去替代我们的硬件定时器，但是精度不高，毕竟是软件模拟的，而且最小的定时单位是我们的时间节拍，也就是1毫秒以上</p><h2 id="壹：软件定时器的守护任务"><a href="#壹：软件定时器的守护任务" class="headerlink" title="壹：软件定时器的守护任务"></a>壹：软件定时器的守护任务</h2><p>软件定时器是通过守护任务去实现的，我们开启定时器的功能后也就是<u>configUSE_TIMERS 被设置为 1</u> 时，我们的<u>系统在初始化内核的时候就会创建一个守护任务</u>，这个<u>守护任务就是用于调度我们的软件定时器</u>，其<u>内部实现的原理是通过队列去完成的</u>，就比如说我们的<u>执行相关的定时器的函数，其实他就是向队列中发了一个数据</u>，然后<u>守护任务去做对应的处理，然后就实现了对应的功能</u></p><p><u>既然是任务，我们就可以设置他的优先级，可以通过configTIMER_TASK_PRIORITY去设置</u></p><p><u>一般建议优先级大一点，不然会被其他任务抢走了，使得定时不准确</u></p><p><u>既然有队列，我们也可以设置队列长度，configTIMER_QUEUE_LENGTH就是控制队列长度的宏定义，如果队列满了，就会导致我们的消息发送失败，然后定时器就无法完成特定功能</u></p><h2 id="贰：定时器回调函数"><a href="#贰：定时器回调函数" class="headerlink" title="贰：定时器回调函数"></a>贰：定时器回调函数</h2><p>我们在stm32的开发中就已经有碰到过很多的回调函数了，就比如说我们的中断回调函，其实它和普通的函数并没有什么区别，只是在我们触发中断之后，它会调用我们的另外一个函数进行转跳</p><p>这里只是带给大家回忆一下以前回调函数的概念，并且必须要告诉大家的是在回调函数中是<u><strong>不能使用相关的阻塞函数</strong></u>不然会出大问题</p><h2 id="叁：软件定时器的基本函数"><a href="#叁：软件定时器的基本函数" class="headerlink" title="叁：软件定时器的基本函数"></a>叁：软件定时器的基本函数</h2><h3 id="定时器的创建："><a href="#定时器的创建：" class="headerlink" title="定时器的创建："></a>定时器的创建：</h3><h4 id="动态创建："><a href="#动态创建：" class="headerlink" title="动态创建："></a>动态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params"><span class="type">const</span> TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params"><span class="type">const</span> UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span><br><span class="line"><span class="params">TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment">//xTimerPeriodInTicks: 周期, 以 Tick 为单位</span></span><br><span class="line"><span class="comment">//uxAutoReload: 类型, pdTRUE 表示自动加载, pdFALSE 表示一次性</span></span><br><span class="line"><span class="comment">//pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment">//pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment">//返回值: 成功则返回 TimerHandle_t, 否则返回 NULL</span></span><br></pre></td></tr></table></figure><h4 id="静态创建："><a href="#静态创建：" class="headerlink" title="静态创建："></a>静态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t <span class="title function_">xTimerCreateStatic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                                 TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> * pvTimerID,</span></span><br><span class="line"><span class="params">                                 TimerCallbackFunction_t pxCallbackFunction,</span></span><br><span class="line"><span class="params">                                 StaticTimer_t *pxTimerBuffer )</span>;</span><br><span class="line"><span class="comment">//pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment">//xTimerPeriodInTicks: 周期, 以 Tick 为单位</span></span><br><span class="line"><span class="comment">//uxAutoReload: 类型, pdTRUE 表示自动加载, pdFALSE 表示一次性</span></span><br><span class="line"><span class="comment">//pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment">//pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment">//pxTimerBuffer: 传入一个 StaticTimer_t 结构体, 将在上面构造定时器</span></span><br><span class="line"><span class="comment">//返回值: 成功则返回 TimerHandle_t, 否则返回 NULL</span></span><br></pre></td></tr></table></figure><h3 id="回调函数类型："><a href="#回调函数类型：" class="headerlink" title="回调函数类型："></a>回调函数类型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* TimerCallbackFunction_t)</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"><span class="comment">//我们需要按照这种形式去写我们的回调函数命名,就像下面这种</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span></span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及超时时间（队列写入的等待时间）</span></span><br></pre></td></tr></table></figure><h3 id="启动定时器："><a href="#启动定时器：" class="headerlink" title="启动定时器："></a>启动定时器：</h3><h4 id="普通任务中使用："><a href="#普通任务中使用：" class="headerlink" title="普通任务中使用："></a>普通任务中使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及超时时间（队列写入的等待时间）</span></span><br></pre></td></tr></table></figure><h4 id="中断中使用："><a href="#中断中使用：" class="headerlink" title="中断中使用："></a>中断中使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTimerStartFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"><span class="comment">//传入句柄，判断任务是否需要切换</span></span><br></pre></td></tr></table></figure><h3 id="停止定时器："><a href="#停止定时器：" class="headerlink" title="停止定时器："></a>停止定时器：</h3><p>普通任务中使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及超时时间（队列写入的等待时间）</span></span><br></pre></td></tr></table></figure><p>中断中使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTimerStopFromISR</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"><span class="comment">//传入句柄，判断任务是否需要切换</span></span><br></pre></td></tr></table></figure><h3 id="复位定时器："><a href="#复位定时器：" class="headerlink" title="复位定时器："></a>复位定时器：</h3><h4 id="普通任务中使用：-1"><a href="#普通任务中使用：-1" class="headerlink" title="普通任务中使用："></a>普通任务中使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及超时时间（队列写入的等待时间</span></span><br></pre></td></tr></table></figure><p>中断中使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerResetFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"><span class="comment">//传入句柄，判断任务是否需要切换</span></span><br></pre></td></tr></table></figure><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><h4 id="修改周期："><a href="#修改周期：" class="headerlink" title="修改周期："></a>修改周期：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment">//xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment">//xTicksToWait: 超时时间, 命令写入队列的超时时间</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriodFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h4 id="获取ID："><a href="#获取ID：" class="headerlink" title="获取ID："></a>获取ID：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"><span class="comment">//xTimer: 哪个定时器</span></span><br></pre></td></tr></table></figure><h4 id="修改ID："><a href="#修改ID：" class="headerlink" title="修改ID："></a>修改ID：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTimerSetTimerID</span><span class="params">( TimerHandle_t xTimer, <span class="type">void</span> *pvNewID )</span>;</span><br><span class="line"><span class="comment">//xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment">//pvNewID: 新 ID</span></span><br></pre></td></tr></table></figure><h2 id="肆：软件定时器的使用"><a href="#肆：软件定时器的使用" class="headerlink" title="肆：软件定时器的使用"></a>肆：软件定时器的使用</h2><h3 id="！！使用CubeMX创建默认周期为1，需要自行修改，手动则不需要"><a href="#！！使用CubeMX创建默认周期为1，需要自行修改，手动则不需要" class="headerlink" title="！！使用CubeMX创建默认周期为1，需要自行修改，手动则不需要"></a>！！使用CubeMX创建默认周期为1，需要自行修改，手动则不需要</h3><p>实验：软件定时器的基本使用</p><p>创建两个定时器，一个周期位500ms,一个周期位1000ms</p><p>按下KEY1，定时器启动</p><p>按下KEY2，定时器暂停</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_10</title>
      <link href="/2022/11/12/FreeRTOS-10/"/>
      <url>/2022/11/12/FreeRTOS-10/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章：任务通知"><a href="#第十章：任务通知" class="headerlink" title="第十章：任务通知"></a>第十章：任务通知</h1><p>任务通知是我们整个FreeRTOS当中的最后一个通信工具，然后他是FreeRTOS第8个大版本的时候才更新出来的产物，然后我们目前是第10个版本了，相对来说还是一个比较新的概念，并且它的功能是比较强大的，它可以一定程度上的代替二值信号量，计数信号量，队列，还有我们的事件组,并且最重要的是他是我们任务中自带的一个属性，不需要我们单独去创建对应的结构体，所以他的执行效率也快很多</p><h2 id="壹：任务通知的介绍"><a href="#壹：任务通知的介绍" class="headerlink" title="壹：任务通知的介绍"></a>壹：任务通知的介绍</h2><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有 2 个成员：</p><p>一个是 uint8_t 类型，用来表示通知状态</p><p>一个是 uint32_t 类型，用来表示通知值</p><p>任务状态一共有三种：</p><p>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知（默认是这个）</p><p>taskWAITING_NOTIFICATION：任务在等待通知</p><p>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为 pending(有数据了，待处理)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> taskNOT_WAITING_NOTIFICATION ( ( uint8_t ) 0 ) <span class="comment">/* 也是初始状态*/</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> taskWAITING_NOTIFICATION ( ( uint8_t ) 1 )</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> taskNOTIFICATION_RECEIVED ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure><p>我们的通知值，就可以把他当作一个32位的变量，</p><p>如果只用它来存0和1，他就可以当作二值信号量使用</p><p>如果只用它来存数字0~N，就可以当作计数信号量</p><p>如果用它来存“信息”的话，可以当作队列来使用</p><p>如果每一位单独作为标志位，可以当作事件组来使用</p><p>大概该就是这样一个使用方法，说的太罗嗦反而难以来理解</p><h2 id="贰：任务通知的基本函数"><a href="#贰：任务通知的基本函数" class="headerlink" title="贰：任务通知的基本函数"></a>贰：任务通知的基本函数</h2><p>由于他是任务本身自带的属性，所以默认情况是不需要创建的，不过可以在宏定义中关闭，可以节省五个字节的内存，由于我们的任务通知它可以使用的功能有点多，所以它的函数也分为了两个版本，一个简化版和一个全功能版，然后这里我们会分别进行介绍</p><h3 id="简化版："><a href="#简化版：" class="headerlink" title="简化版："></a>简化版：</h3><h4 id="发出通知："><a href="#发出通知：" class="headerlink" title="发出通知："></a>发出通知：</h4><h5 id="普通任务中使用："><a href="#普通任务中使用：" class="headerlink" title="普通任务中使用："></a>普通任务中使用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"><span class="comment">//传入接收任务的句柄</span></span><br><span class="line"><span class="comment">//使用以后接收的任务其状态将会改为taskNOTIFICATION_RECEIVED，并且使得我们的任务通知加1</span></span><br><span class="line"><span class="comment">//返回pdPASS</span></span><br></pre></td></tr></table></figure><h5 id="中断中使用："><a href="#中断中使用：" class="headerlink" title="中断中使用："></a>中断中使用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskHandle, </span></span><br><span class="line"><span class="params">                            BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><p><u>!!!不论发送是否有效，都是返回pdPASS</u></p><h4 id="接收通知："><a href="#接收通知：" class="headerlink" title="接收通知："></a>接收通知：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//xClearCountOnExit:</span></span><br><span class="line"><span class="comment">//pdTRUE：把通知值清零</span></span><br><span class="line"><span class="comment">//pdFALSE：如果通知值大于 0，则把通知值减一</span></span><br><span class="line"><span class="comment">//xTicksToWait:</span></span><br><span class="line"><span class="comment">//0：不等待，即刻返回</span></span><br><span class="line"><span class="comment">//portMAX_DELAY：一直等待，直到通知值大于0</span></span><br><span class="line"><span class="comment">//返回清除之前的数值</span></span><br></pre></td></tr></table></figure><p>从这里可以看出来我们的这个简单版本他只能模拟二值信号量和计数信号量</p><h3 id="全功能版："><a href="#全功能版：" class="headerlink" title="全功能版："></a>全功能版：</h3><h4 id="发出通知：-1"><a href="#发出通知：-1" class="headerlink" title="发出通知："></a>发出通知：</h4><h5 id="普通任务中使用：-1"><a href="#普通任务中使用：-1" class="headerlink" title="普通任务中使用："></a>普通任务中使用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                        <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                        eNotifyActioneAction)</span>;</span><br><span class="line"><span class="comment">//xTaskToNotif:任务句柄，给哪个任务发通知</span></span><br><span class="line"><span class="comment">//ulValue:取决于eAction</span></span><br><span class="line"><span class="comment">//eAction：</span></span><br><span class="line"><span class="comment">//eNoAction：更新通知状态为&quot;pending&quot;，未使用 ulValue，这个选项相当于二进制信号量</span></span><br><span class="line"><span class="comment">//eSetBits：通知值 = 原来的通知值|ulValue，按位或，相当于事件组</span></span><br><span class="line"><span class="comment">//eIncrement：通知值 = 原来的通知值 + 1，未使用 ulValue，相当于计数型信号量（二值信号量）</span></span><br><span class="line"><span class="comment">//eSetValueWithoutOverwrite：如果数据未读状态，则此次调用不做任何事返回pdFAIL，否者写入ulValue</span></span><br><span class="line"><span class="comment">//相当于队列</span></span><br><span class="line"><span class="comment">//eSetValueWithOverwrite：直接用ulValue覆盖原来的数值，相当于队列的覆盖操作</span></span><br></pre></td></tr></table></figure><h5 id="中断中使用：-1"><a href="#中断中使用：-1" class="headerlink" title="中断中使用："></a>中断中使用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTaskNotifyFromISR</span><span class="params">( TaskHandle_txTaskToNotify,</span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span>ulValue,</span></span><br><span class="line"><span class="params">                            eNotifyActioneAction,</span></span><br><span class="line"><span class="params">                            BaseType_t*pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h4 id="接收通知"><a href="#接收通知" class="headerlink" title="接收通知:"></a>接收通知:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//ulBitsToClearOnEntry:</span></span><br><span class="line"><span class="comment">//在 xTaskNotifyWait 入口处，要清除通知值的哪些位？通知状态不是&quot;pending&quot;的情</span></span><br><span class="line"><span class="comment">//况下，才会清除。它的本意是我想等待某些事件发生，所以先把&quot;旧数据&quot;的某些位清零。</span></span><br><span class="line"><span class="comment">//ulBitsToClearOnExit:</span></span><br><span class="line"><span class="comment">//在 xTaskNotifyWait 出口处，如果不是因为超时推出，而是因为得到了数据而退出时</span></span><br><span class="line"><span class="comment">//pulNotificationValue:</span></span><br><span class="line"><span class="comment">//用来取出通知值</span></span><br><span class="line"><span class="comment">//xTicksToWait:</span></span><br><span class="line"><span class="comment">//0：不等待，即刻返回</span></span><br><span class="line"><span class="comment">//portMAX_DELAY：一直等待</span></span><br><span class="line"><span class="comment">//返回：</span></span><br><span class="line"><span class="comment">//pdPASS：成功</span></span><br><span class="line"><span class="comment">//pdFAIL：没有得到通知</span></span><br></pre></td></tr></table></figure><p>看起来参数有些复杂，但是使用起来其实没有那么复杂，接下啦我们就是带着大家去使用一下我们的任务通知</p><h2 id="叁：任务通知的使用"><a href="#叁：任务通知的使用" class="headerlink" title="叁：任务通知的使用"></a>叁：任务通知的使用</h2><h3 id="实验一：模拟计数信号量"><a href="#实验一：模拟计数信号量" class="headerlink" title="实验一：模拟计数信号量"></a>实验一：模拟计数信号量</h3><h3 id="实验二：模拟事件组"><a href="#实验二：模拟事件组" class="headerlink" title="实验二：模拟事件组"></a>实验二：模拟事件组</h3><h3 id="实验四：模拟队列"><a href="#实验四：模拟队列" class="headerlink" title="实验四：模拟队列"></a>实验四：模拟队列</h3>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_09</title>
      <link href="/2022/11/12/FreeRTOS-09/"/>
      <url>/2022/11/12/FreeRTOS-09/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章：事件组（event-group）"><a href="#第九章：事件组（event-group）" class="headerlink" title="第九章：事件组（event group）"></a>第九章：事件组（<strong>event group</strong>）</h1><p>前面我们使用二值信号量进行数据的同步，但是我们在使用中会遇到这样一种情况，就比如说我们一个任务，他执行之前需要经过多个条件进行判断，当这多个条件全部满足或者多个条件中的某一个条件满足他才会执行</p><p>这种情况下我们使用二值信号量和互斥量好像都不靠谱，所以我们的FreeRTOS就有了另外一种东西也就是我们的事件组</p><h2 id="壹：事件组的功能简介"><a href="#壹：事件组的功能简介" class="headerlink" title="壹：事件组的功能简介"></a>壹：事件组的功能简介</h2><p>我们的二值信号量就很像我们的标志位，而我们的事件组它就是24个标志位组合在一起，高八位保留</p><p><img src="/img/blog/image-20220814103344309.png" alt="image-20220814103344309"></p><p>这样的话我们可以判断的附加条件就有很多元化，我们就可以完成或操作或者与操作，这样说可能没有什么概念，这里简单举一个例子：</p><p>就比如说我们发射核弹的任务，他必须要经过国家主席还有总司令同时确认，才可以发射出去，也就是他们俩的标志位都为一才可以执行，这个是与操作</p><p>就比如说你客厅的锁，只需要你家里人任何一个人有钥匙就都可以将它打开，这就是或操作</p><p>相对来说它的概念是比较容易理解的，然后我们这里直接讲一下它的常用函数</p><h2 id="贰：事件组的基本函数"><a href="#贰：事件组的基本函数" class="headerlink" title="贰：事件组的基本函数"></a>贰：事件组的基本函数</h2><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><h4 id="动态创建："><a href="#动态创建：" class="headerlink" title="动态创建："></a>动态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="comment">//返回句柄或者NULL</span></span><br></pre></td></tr></table></figure><h4 id="静态创建："><a href="#静态创建：" class="headerlink" title="静态创建："></a>静态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreateStatic</span><span class="params">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span>;</span><br><span class="line"><span class="comment">//传入句柄</span></span><br></pre></td></tr></table></figure><h3 id="设置事件组："><a href="#设置事件组：" class="headerlink" title="设置事件组："></a>设置事件组：</h3><h4 id="正常任务使用："><a href="#正常任务使用：" class="headerlink" title="正常任务使用："></a>正常任务使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t<span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class="line"><span class="comment">//传入句柄以及需要设置的标志位</span></span><br><span class="line"><span class="comment">//标志位为0不改变标志位</span></span><br><span class="line"><span class="comment">//标志位为1对应标志位置1</span></span><br></pre></td></tr></table></figure><h4 id="中断中使用："><a href="#中断中使用：" class="headerlink" title="中断中使用："></a>中断中使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params"> BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"><span class="comment">//传入句柄、标志位、判断是否需要切换任务</span></span><br></pre></td></tr></table></figure><h3 id="等待事件组："><a href="#等待事件组：" class="headerlink" title="等待事件组："></a>等待事件组：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//xEventGroup:任务句柄</span></span><br><span class="line"><span class="comment">//uxBitsToWaitFor：判断标志位</span></span><br><span class="line"><span class="comment">//xClearOnExit：是否清楚标志位中的uxBitsToWaitFor这几位</span></span><br><span class="line"><span class="comment">//xWaitForAllBits：判断模式</span></span><br><span class="line"><span class="comment">//pdTRUE: 等待的位，全部为 1;</span></span><br><span class="line"><span class="comment">//pdFALSE: 等待的位，某一个为 1 即可</span></span><br><span class="line"><span class="comment">//xTicksToWait：等待时间</span></span><br><span class="line"><span class="comment">//0：立即返回</span></span><br><span class="line"><span class="comment">//portMAX_DELAY：知道接收到为止</span></span><br><span class="line"><span class="comment">//返回值：事件组的值</span></span><br></pre></td></tr></table></figure><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><p>可查阅相关手册或资料，这里不做赘述</p><h2 id="叁：事件组的使用"><a href="#叁：事件组的使用" class="headerlink" title="叁：事件组的使用"></a>叁：事件组的使用</h2><h3 id="实验一：事件组与操作判断模拟"><a href="#实验一：事件组与操作判断模拟" class="headerlink" title="实验一：事件组与操作判断模拟"></a>实验一：事件组与操作判断模拟</h3><p>创建一个事件组，以及三个任务，实现三个按键同时按下，串口打印对应消息</p><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>三个按键都最少按下一次才可以发射导弹</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们将判断模式设置为了全部符合，所以才会有此效果</p><h3 id="实验二：事件组与操作判断模拟"><a href="#实验二：事件组与操作判断模拟" class="headerlink" title="实验二：事件组与操作判断模拟"></a>实验二：事件组与操作判断模拟</h3><p>创建一个事件组，以及三个任务，实现三个按键只要有一个按下，串口打印对应消息</p><h3 id="现象：-1"><a href="#现象：-1" class="headerlink" title="现象："></a>现象：</h3><p>无论按下哪一个按键都会发射导弹</p><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>我们将判断模式设置为了局部符合，所以才会有此效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_08</title>
      <link href="/2022/11/12/FreeRTOS-08/"/>
      <url>/2022/11/12/FreeRTOS-08/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章：互斥量（Mutex）"><a href="#第八章：互斥量（Mutex）" class="headerlink" title="第八章：互斥量（Mutex）"></a>第八章：互斥量（Mutex）</h1><p> 在我们的项目开发中，可能会有多个任务，共用一个资源的情况，为了避免其发生冲突，我们前面介绍了，我们的二值信号量可以一定程度上避免这种事情，但是它多数还是用于同步的状况，如果我们的任务之间出现优先级的差异，就会出现优先级反转的问题</p><h2 id="壹：二值信号量的优先级反转现象"><a href="#壹：二值信号量的优先级反转现象" class="headerlink" title="壹：二值信号量的优先级反转现象"></a>壹：二值信号量的优先级反转现象</h2><h3 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h3><p>创建三个任务优先级从高到低，名字分别为H_Task、M_Task、L_Task</p><p>在H_Task和L_Task中加入二值信号量，观察任务状况</p><p><img src="/img/blog/image-20220813121911582.png" alt="image-20220813121911582"></p><p>分析：当出现中间层优先级任务，我们的任务一等待时间将会大大增长，使得任务一明明优先级最高，任务还是最后执行的</p><p>然后为了避免这种情况的出现，就有了互斥量的这个概念</p><h2 id="贰：互斥量"><a href="#贰：互斥量" class="headerlink" title="贰：互斥量"></a>贰：互斥量</h2><h3 id="互斥量的上锁机制"><a href="#互斥量的上锁机制" class="headerlink" title="互斥量的上锁机制"></a>互斥量的上锁机制</h3><p>由于上面的那种情况导致我们的二值信号量，通常都是用来进行数据的同步一个负责发送数据，然后一个负责同步数据</p><p>而我们的互斥量，其实它更像一个上锁的机制，两个任务需要公用一个资源，所以我们可以把互斥量又叫做互斥锁</p><p><img src="/img/blog/image-20220813135859589.png" alt="image-20220813135859589"></p><p>这里为了通俗易懂就找了一个上厕所的例子，给大家解释一下</p><p>厕所：任务公用的资源</p><p>小人：使用资源的任务</p><p>上锁：“厕所处于使用状态”</p><p>开锁：使用完了，处于空闲状态</p><p>然后我们去上卫生间的话，我们肯定会有一个上锁的操作，这样的话别人就不会闯进来了，当我们上完厕所之后，我们再将锁打开，这样的话才会有下一个人进入</p><h3 id="互斥量的优先级继承机制"><a href="#互斥量的优先级继承机制" class="headerlink" title="互斥量的优先级继承机制"></a>互斥量的优先级继承机制</h3><h4 id="二值信号量："><a href="#二值信号量：" class="headerlink" title="二值信号量："></a>二值信号量：</h4><p>我们高优先级的任务和低优先级的任务，他们两个有一个特殊的联系，就是他俩只有一个人带了“卫生纸”，所以尽管他优先级很高，但是没有卫生纸，他也还是上不了厕所，但是在FreeRTOS的世界里，低优先级的任务又会被高优先级的任务插队，只能等比他优先级高的任务上完厕所，自己才能进去，这导致明明优先级最高的“大哥”，等的时间更久</p><h4 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h4><p>互斥量的出现就是去弥补二值信号量它的缺点，你想想你作为大哥，有人插你小弟的队，这不就等于是插你的队吗？大哥气不过，就和所有人宣布，我的小弟就是我，谁要敢插他的队我就打谁</p><p><img src="/img/blog/image-20220813142424227.png" alt="image-20220813142424227"></p><h2 id="叁：互斥量的基本函数："><a href="#叁：互斥量的基本函数：" class="headerlink" title="叁：互斥量的基本函数："></a>叁：互斥量的基本函数：</h2><p>互斥量系统默认是开启的也就是#defineconfigUSE_MUTEXES1</p><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><h4 id="动态创建："><a href="#动态创建：" class="headerlink" title="动态创建："></a>动态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t<span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="comment">//创建互斥量，成功的话返回句柄，失败返回NULL</span></span><br></pre></td></tr></table></figure><h4 id="静态创建："><a href="#静态创建：" class="headerlink" title="静态创建："></a>静态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutexStatic</span><span class="params">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"><span class="comment">//传入句柄即可删除</span></span><br></pre></td></tr></table></figure><h3 id="Give-Take"><a href="#Give-Take" class="headerlink" title="Give\Take:"></a>Give\Take:</h3><h4 id="！Take和Give需要成对使用"><a href="#！Take和Give需要成对使用" class="headerlink" title="！Take和Give需要成对使用"></a><u>！Take和Give需要成对使用</u></h4><h4 id="正常任务中使用："><a href="#正常任务中使用：" class="headerlink" title="正常任务中使用："></a>正常任务中使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"><span class="comment">//传入句柄</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">//传入句柄以及等待时间</span></span><br></pre></td></tr></table></figure><h4 id="中断中使用："><a href="#中断中使用：" class="headerlink" title="中断中使用："></a>中断中使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line">BaseType_t<span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br></pre></td></tr></table></figure><p>只有函数的创建是不一样的，删除以及其他操作基本上都是完全相同的，这里就不去，过多赘述，我们直接往下面看它的实战吧</p><h2 id="肆：互斥量的使用"><a href="#肆：互斥量的使用" class="headerlink" title="肆：互斥量的使用"></a>肆：互斥量的使用</h2><h3 id="实验：上厕所模拟试验"><a href="#实验：上厕所模拟试验" class="headerlink" title="实验：上厕所模拟试验"></a>实验：上厕所模拟试验</h3><p>同样是三个任务优先级，分别是从高到低，然后在任务一和任务三中使用我们的互斥量，然后观察它的执行顺序</p><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>我们的最高优先级和最低优先级的任务将会“连续执行”中间优先级的任务反而是最后执行</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>互斥量具有优先级继承的机制，在上锁期间其他的任务无法进行抢占</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_07</title>
      <link href="/2022/11/12/FreeRTOS-07/"/>
      <url>/2022/11/12/FreeRTOS-07/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章：信号量"><a href="#第七章：信号量" class="headerlink" title="第七章：信号量"></a><strong>第七章：信号量</strong></h1><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间，消息队列用于传输多个数据，占用时间按也相对较长，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，就比如说：</p><p>使用我们的LED显示屏，去显示我们读取到的温湿度，如果我们的屏幕按固定的时间去刷新，就会非常的耗资源，但是如果使用我们的信号量，在我们读取到数据之后给屏幕发送一个信号，再让屏幕刷新，这样的话可以达到同样的效果，并且可以减少资源的占用，而且可以达到同步的效果</p><h2 id="壹：信号量的特征"><a href="#壹：信号量的特征" class="headerlink" title="壹：信号量的特征"></a><strong>壹：信号量的特征</strong></h2><p>信号量这个名字，我们可以把它拆分来看，<u>信号可以起到通知信号的作用</u>，然后我们的量<u>还可以用来表示资源的数量</u>，当<u>我们的量只有0和1的时候，它就可以被称作二值的信号量</u>，只有两个状态，<u>当我们的那个量没有限制的时候，它就可以被称作为计数型信号量</u></p><h3 id="信号量也是队列的一种"><a href="#信号量也是队列的一种" class="headerlink" title="信号量也是队列的一种"></a><u>信号量也是队列的一种</u></h3><p>我们前面讲过队列创建的时候，需要传入队列的长度以及队列的大小，而我们的信号量其实就是一种特殊的队列，只不过它的大小是0，毕竟我们的信号量是不需要传递数据，只需要传递信号，然后长度是N，当N&#x3D;1的时候就是二值信号量，他就只有0和1两个状态，<u>这里的0和1两个状态是指被填入和被拿走这两个状态</u>，当N&gt;1时，就是我们的计数信号量，他也不传递数据，只是传递一个数量值，一般是记录我们设备的资源数量</p><h3 id="二值信号量："><a href="#二值信号量：" class="headerlink" title="二值信号量："></a>二值信号量：</h3><p>二值信号量其实就是一个长度为1，然后大小为零的队列，然后它的状态只有0和1两种状态，也就是被写入和被取走的两种状态，通常情况下，我们用它来进行数据同步，还是以前面的那个例子，我们在项目中添加一个二值信号量，当我们读取到了温湿度，我们就把我们的二值信号量填上也就是置1，然后我们就可以在屏幕显示的那个任务中进行判断，当他读到了新数据，我们再进行屏幕的刷新，这样一说，是不是感觉就很像我们自己平时在程序中设置的那个变量flag，当我们完成了某件事，然后我们就把它标志为给打开，等屏幕刷新我们再把它清除</p><h3 id="计数信号量："><a href="#计数信号量：" class="headerlink" title="计数信号量："></a>计数信号量：</h3><p>而我们的计数信号量其实就是二指信号量的升级版，我们那只是信号量只有0和1两种状态，而我们的这个就有很多很多种状态，通常情况下是用来记录系统的资源，就比如说我们记录一个车库里的辆车，每当有人来停车或者取车的时候他的数量都会进行对应的加减，我们就可以很轻松的看到我们车库的状态，然后也知道车库里面有几辆车</p><p>两种信号大同小异，我们接下来讲一下相关的用法</p><h2 id="贰：二值信号量的基本操作"><a href="#贰：二值信号量的基本操作" class="headerlink" title="贰：二值信号量的基本操作"></a>贰：二值信号量的基本操作</h2><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><p>手动创建默认初始值为0，CubeMX创建默认为1</p><h4 id="动态创建："><a href="#动态创建：" class="headerlink" title="动态创建："></a>动态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t<span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="comment">//无需传入参数</span></span><br><span class="line"><span class="comment">//返回句柄，非 NULL 表示成功</span></span><br><span class="line"><span class="comment">//默认初始化内部是空</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t<span class="title function_">vSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="comment">//此函数已过时，和上面的区别是信号量创建默认就是1</span></span><br></pre></td></tr></table></figure><h4 id="静态创建："><a href="#静态创建：" class="headerlink" title="静态创建："></a>静态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t<span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">StaticSemaphore_t *pxSemaphoreBuffer)</span>;</span><br><span class="line"><span class="comment">//几乎不使用，了解即可</span></span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span><span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_txSemaphore )</span>;</span><br><span class="line"><span class="comment">//传入信号量句柄，无返回值</span></span><br></pre></td></tr></table></figure><h3 id="Take-x2F-Give："><a href="#Take-x2F-Give：" class="headerlink" title="Take&#x2F;Give："></a>Take&#x2F;Give：</h3><h4 id="Give：释放（置1）"><a href="#Give：释放（置1）" class="headerlink" title="Give：释放（置1）"></a>Give：释放（置1）</h4><h5 id="正常任务中使用"><a href="#正常任务中使用" class="headerlink" title="正常任务中使用"></a>正常任务中使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_txSemaphore )</span>;</span><br><span class="line"><span class="comment">//传入信号量句柄，信号量将会被置1</span></span><br><span class="line"><span class="comment">//返回：</span></span><br><span class="line"><span class="comment">//pdTRUE 表示成功</span></span><br><span class="line"><span class="comment">//如果二进制信号量的计数值已经是 1，再次调用此函数则返回失败</span></span><br></pre></td></tr></table></figure><h5 id="中断中使用"><a href="#中断中使用" class="headerlink" title="中断中使用"></a>中断中使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">( SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及判断是否需要切换任务</span></span><br></pre></td></tr></table></figure><h4 id="Take：获取（清空）"><a href="#Take：获取（清空）" class="headerlink" title="Take：获取（清空）"></a>Take：获取（清空）</h4><h5 id="正常任务中使用-1"><a href="#正常任务中使用-1" class="headerlink" title="正常任务中使用"></a>正常任务中使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_txSemaphore,TickType_txTicksToWait)</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及等待等待时间</span></span><br><span class="line"><span class="comment">//0：不阻塞，马上返回</span></span><br><span class="line"><span class="comment">//portMAX_DELAY: 一直阻塞直到成功</span></span><br><span class="line"><span class="comment">//返回：pdTRUE 表示成功</span></span><br></pre></td></tr></table></figure><h5 id="中断中使用："><a href="#中断中使用：" class="headerlink" title="中断中使用："></a>中断中使用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(SemaphoreHandle_txSemaphore,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">//传入句柄，以及判断是否需要切换任务</span></span><br></pre></td></tr></table></figure><h2 id="叁：二值信号量的使用"><a href="#叁：二值信号量的使用" class="headerlink" title="叁：二值信号量的使用"></a><strong>叁：二值信号量的使用</strong></h2><h3 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h3><p>创建任务一：模拟温湿度采集（按键按下采集成功）</p><p>创建任务二：模拟LED屏幕刷新（使用串口发送信息）</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象:"></a>现象:</h3><p>我们的按键和我们的串口成功达成了同步，只有当我们按键释放了信号量，我们的串口才有机会发送信息</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>当我们的按键一按下时成释放信号量，若多次释放将会返回错误信息，串口也是，按下按键成功接收，多次按下，当等待时间为0时，返回失败，为最大值时，将无限等待</p><h2 id="肆：计数信号量的基本操作"><a href="#肆：计数信号量的基本操作" class="headerlink" title="肆：计数信号量的基本操作"></a><strong>肆：计数信号量</strong>的基本操作</h2><h3 id="使用时configSUPPORT-DYNAMIC-ALLOCATION需要设置为1"><a href="#使用时configSUPPORT-DYNAMIC-ALLOCATION需要设置为1" class="headerlink" title="!!使用时configSUPPORT_DYNAMIC_ALLOCATION需要设置为1"></a><u>!!使用时configSUPPORT_DYNAMIC_ALLOCATION需要设置为1</u></h3><h3 id="创建：-1"><a href="#创建：-1" class="headerlink" title="创建："></a>创建：</h3><p><u><strong>如果使用的Cube MX的话其默认初始化是最大值</strong></u></p><h4 id="动态创建：-1"><a href="#动态创建：-1" class="headerlink" title="动态创建："></a>动态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">( UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">                                            UBaseType_t uxInitialCount)</span>;</span><br><span class="line"><span class="comment">//参数：最大计数值、初始化计数值</span></span><br><span class="line"><span class="comment">//返回：信号量句柄</span></span><br></pre></td></tr></table></figure><h4 id="静态创建：-1"><a href="#静态创建：-1" class="headerlink" title="静态创建："></a>静态创建：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxInitialCount</span></span><br><span class="line"><span class="params">                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>; </span><br><span class="line"><span class="comment">//几乎不会使用</span></span><br></pre></td></tr></table></figure><h3 id="删除：-1"><a href="#删除：-1" class="headerlink" title="删除："></a>删除：</h3><p>同二值信号量，自行转跳</p><h3 id="Take-x2F-Give：-1"><a href="#Take-x2F-Give：-1" class="headerlink" title="Take&#x2F;Give："></a>Take&#x2F;Give：</h3><p>同二值信号量，自行转跳</p><h3 id="读取数值："><a href="#读取数值：" class="headerlink" title="读取数值："></a>读取数值：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxSemaphoreGetCount</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"><span class="comment">//传入信号量句柄（二值信号量通用），返回数值</span></span><br></pre></td></tr></table></figure><h2 id="伍：计数信号量的使用"><a href="#伍：计数信号量的使用" class="headerlink" title="伍：计数信号量的使用"></a><strong>伍：计数信号量的使用</strong></h2><h3 id="实验二："><a href="#实验二：" class="headerlink" title="实验二："></a>实验二：</h3><h4 id="模拟车库计数器"><a href="#模拟车库计数器" class="headerlink" title="模拟车库计数器"></a>模拟车库计数器</h4><p>创建计数信号量大小为10</p><p>任务一：（按键一）可以将车停入车库（按键二）可以将车开出车库</p><p>任务二：串口每2秒显示一下车库内车辆数据</p><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>我们可以通过按键一和按键二去停车还有取出车辆，并且间隔两秒打印出车库内的状况</p><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>我们成功使用对应的函数，将我们的车停入到车库以及开出车库并且使用，还能获取到车库内的状况</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_06</title>
      <link href="/2022/11/12/FreeRTOS-06/"/>
      <url>/2022/11/12/FreeRTOS-06/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章：消息队列-queue"><a href="#第六章：消息队列-queue" class="headerlink" title="第六章：消息队列(queue)"></a>第六章：消息队列(queue)</h1><p>队列(queue)可以用于”任务到任务”、”任务到中断”、”中断到任务”直接传输信息，可以实现任务之间的通信</p><h2 id="壹：消息队列的介绍"><a href="#壹：消息队列的介绍" class="headerlink" title="壹：消息队列的介绍"></a><strong>壹：消息队列的介绍</strong></h2><p>消息队列就是一个像容器一样的东西，我们所有的任务都可以往内部写消息，然后队列会将我们的消息按顺序存下来，所有的任务也可以按顺序将其读出来</p><p>需要注意的几点：</p><h3 id="队列需要明确数据的大小以及队列的长度"><a href="#队列需要明确数据的大小以及队列的长度" class="headerlink" title="队列需要明确数据的大小以及队列的长度"></a>队列需要明确数据的大小以及队列的长度</h3><h3 id="写队列和读队列都是采用复制的方式将数据复制过去使用"><a href="#写队列和读队列都是采用复制的方式将数据复制过去使用" class="headerlink" title="写队列和读队列都是采用复制的方式将数据复制过去使用"></a><u>写队列和读队列都是采用复制的方式将数据复制过去使用</u></h3><h3 id="数据的操作默认采用先进先出的方法-FIFO，First-In-First-Out-：写数据时放到尾部，读数据时从头部读"><a href="#数据的操作默认采用先进先出的方法-FIFO，First-In-First-Out-：写数据时放到尾部，读数据时从头部读" class="headerlink" title="数据的操作默认采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读"></a>数据的操作默认采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读</h3><p><img src="/img/blog/image-20220811090249438.png" alt="image-20220811090249438"></p><h4 id="也存在后进先出的模式-LIFO-不过使用较少"><a href="#也存在后进先出的模式-LIFO-不过使用较少" class="headerlink" title="也存在后进先出的模式(LIFO),不过使用较少"></a>也存在后进先出的模式(LIFO),不过使用较少</h4><h4 id="存在函数可以强制写队列头部：覆盖头部数据"><a href="#存在函数可以强制写队列头部：覆盖头部数据" class="headerlink" title="存在函数可以强制写队列头部：覆盖头部数据"></a>存在函数可以强制写队列头部：覆盖头部数据</h4><p>这里都是一些简单的概述，让大伙对我们的消息队列有一个基本的概念，然后我们现在开始教大家如何进行创建队列以及我们队列的基本使用</p><h2 id="贰：消息队列的最基本操作"><a href="#贰：消息队列的最基本操作" class="headerlink" title="贰：消息队列的最基本操作"></a><strong>贰：消息队列的最基本操作</strong></h2><h3 id="队列的创建："><a href="#队列的创建：" class="headerlink" title="队列的创建："></a>队列的创建：</h3><h4 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t<span class="title function_">xQueueCreate</span><span class="params">(UBaseType_tuxQueueLength, UBaseType_tuxItemSize)</span>;</span><br><span class="line"><span class="comment">//传入参数（队列长度，每个数据的大小：以字节为单位）</span></span><br><span class="line"><span class="comment">//返回 非零：创建成功返回消息队列的句柄NULL：创建失败</span></span><br></pre></td></tr></table></figure><h4 id="静态创建"><a href="#静态创建" class="headerlink" title="静态创建"></a>静态创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t<span class="title function_">xQueueCreateStatic</span><span class="params">(UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params"> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params"> <span class="type">uint8_t</span> *pucQueueStorageBuffer,</span></span><br><span class="line"><span class="params"> StaticQueue_t *pxQueueBuffer)</span>;</span><br></pre></td></tr></table></figure><h3 id="队列复位"><a href="#队列复位" class="headerlink" title="队列复位"></a>队列复位</h3><p>​队列刚被创建时，里面没有数据；使用过程中可以调用 xQueueReset()把队列恢复为初始状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xQueueReset</span><span class="params">( QueueHandle_tpxQueue)</span>;<span class="comment">//传入队列句柄即可</span></span><br></pre></td></tr></table></figure><h3 id="删除队列"><a href="#删除队列" class="headerlink" title="删除队列"></a>删除队列</h3><p>​删除队列的函数为 vQueueDelete()，只能删除使用动态方法创建的队列，它会释放内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span><span class="title function_">vQueueDelete</span><span class="params">( QueueHandle_txQueue )</span>;<span class="comment">//传入队列句柄即可</span></span><br></pre></td></tr></table></figure><h3 id="写队列"><a href="#写队列" class="headerlink" title="写队列"></a>写队列</h3><p>​可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在 ISR（中断） 中使用</p><h5 id="往后写入"><a href="#往后写入" class="headerlink" title="往后写入"></a>往后写入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params"> TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//需要写的队列、写入数据的指针、等待时间</span></span><br><span class="line"><span class="comment">//往队列尾部写入数据，如果没有空间，阻塞时间为 xTicksToWait</span></span><br><span class="line"><span class="comment">//（如果被设为 0，无法写入数据时函数会立刻返回；如果被设为 portMAX_DELAY，则会一直阻塞直到有数据可写）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params"> TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">//参数:</span></span><br><span class="line"><span class="comment">//需要写的队列、写入数据的指针、等待时间</span></span><br><span class="line"><span class="comment">//往队列尾部写入数据，如果没有空间，阻塞时间为 xTicksToWait</span></span><br><span class="line"><span class="comment">//（如果被设为 0，无法写入数据时函数会立刻返回；如果被设为 portMAX_DELAY，则会一直阻塞直到有数据可写）</span></span><br></pre></td></tr></table></figure><p>这两个默认是等效的，一般使用前面的</p><h4 id="往前写入"><a href="#往前写入" class="headerlink" title="往前写入"></a>往前写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_txQueueSendToFront(QueueHandle_txQueue,</span><br><span class="line"> const void*pvItemToQueue,</span><br><span class="line"> TickType_txTicksToWait);</span><br></pre></td></tr></table></figure><p>中断中的函数</p><h4 id="中断写入"><a href="#中断写入" class="headerlink" title="中断写入"></a>中断写入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xQueueSendToBackFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line">BaseType_t<span class="title function_">xQueueSendToFrontFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">//对某个队列而言，可能有不止一个任务处于阻塞态在等待其数据有效。调用 xQueueSendToFrontFromISR()或 xQueueSendToBackFromISR()会使得队列数据变为有效，所以会让其中一个等待任务切出阻塞态。如果调用这两个 API 函数使得一个任务解除阻塞，并且这个任务的优先级高于当前任务(也就是被中断的任务)，那么 API 会在函数内部将*pxHigherPriorityTaskWoken 设为 pdTRUE。如果这两个 API 函数将此值设为 pdTRUE，则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。</span></span><br></pre></td></tr></table></figure><h3 id="读队列"><a href="#读队列" class="headerlink" title="读队列"></a>读队列</h3><h4 id="普通读"><a href="#普通读" class="headerlink" title="普通读"></a>普通读</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params"> TickType_t xTicksToWait )</span>;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//队列句柄、数据存放地指针、等待时间</span></span><br><span class="line"><span class="comment">//（如果被设为 0，无法读出数据时函数会立刻返回；如果被设为 portMAX_DELAY，则会一直阻塞直到有数据可读）</span></span><br></pre></td></tr></table></figure><h4 id="中断读"><a href="#中断读" class="headerlink" title="中断读"></a>中断读</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xQueueReceiveFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *pvBuffer,</span></span><br><span class="line"><span class="params"> BaseType_t *pxTaskWoken)</span>;</span><br></pre></td></tr></table></figure><h3 id="队列查询"><a href="#队列查询" class="headerlink" title="队列查询"></a>队列查询</h3><h4 id="查询队列可用数据个数"><a href="#查询队列可用数据个数" class="headerlink" title="查询队列可用数据个数"></a>查询队列可用数据个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxQueueMessagesWaiting</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br><span class="line"><span class="comment">//返回队列中可用数据的个数</span></span><br></pre></td></tr></table></figure><h4 id="查询队列可用空间个数"><a href="#查询队列可用空间个数" class="headerlink" title="查询队列可用空间个数"></a>查询队列可用空间个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxQueueSpacesAvailable</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br><span class="line"><span class="comment">//返回队列中可用空间的个数</span></span><br></pre></td></tr></table></figure><h3 id="队列覆盖（只有长度是一才可用）"><a href="#队列覆盖（只有长度是一才可用）" class="headerlink" title="队列覆盖（只有长度是一才可用）"></a>队列覆盖（只有长度是一才可用）</h3><h4 id="普通覆盖"><a href="#普通覆盖" class="headerlink" title="普通覆盖"></a>普通覆盖</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueOverwrite</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> * pvItemToQueue)</span>;</span><br><span class="line"><span class="comment">//xQueue: 写哪个队列</span></span><br><span class="line"><span class="comment">//pvItemToQueue: 数据地址</span></span><br><span class="line"><span class="comment">//返回值: pdTRUE 表示成功, pdFALSE 表示失败</span></span><br></pre></td></tr></table></figure><h4 id="中断覆盖"><a href="#中断覆盖" class="headerlink" title="中断覆盖"></a>中断覆盖</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xQueueOverwriteFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params"> BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params"> )</span>;</span><br></pre></td></tr></table></figure><h3 id="队列数据偷窥"><a href="#队列数据偷窥" class="headerlink" title="队列数据偷窥"></a>队列数据偷窥</h3><p>正常情况下我们读取完队列中的数据那个数据就会被移除掉，也就是说他只能被读取一次，这时候就要用到我们的偷窥的函数了</p><h4 id="普通偷窥"><a href="#普通偷窥" class="headerlink" title="普通偷窥"></a>普通偷窥</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params"> TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">//xQueue: 偷看哪个队列</span></span><br><span class="line"><span class="comment">//pvBuffer: 数据地址, 用来保存复制出来的数据</span></span><br><span class="line"><span class="comment">//xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class="line"><span class="comment">//返回值: pdTRUE 表示成功, pdFALSE 表示失败</span></span><br></pre></td></tr></table></figure><h4 id="中断偷窥"><a href="#中断偷窥" class="headerlink" title="中断偷窥"></a>中断偷窥</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xQueuePeekFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *pvBuffer,)</span>;</span><br></pre></td></tr></table></figure><h2 id="叁：队列的基本使用"><a href="#叁：队列的基本使用" class="headerlink" title="叁：队列的基本使用"></a><strong>叁：队列的基本使用</strong></h2><h3 id="实验一：创建一个消息队列（使用Cube-MX创建），两个发送任务，一个接收任务"><a href="#实验一：创建一个消息队列（使用Cube-MX创建），两个发送任务，一个接收任务" class="headerlink" title="实验一：创建一个消息队列（使用Cube MX创建），两个发送任务，一个接收任务"></a>实验一：创建一个消息队列（使用Cube MX创建），两个发送任务，一个接收任务</h3><p>发送任务一设置等待时间为0，发送任务二设置等待时间为最大（portMAX_DELAY），接受任务等待时间为0，然后观察实验现象</p><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>队列满了以后，发送任务一无法正常发送，任务二将会死等待，队列空闲以后将会完成发送</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们的发送任务二在队列满了之后将会进入等待的状态，也就是阻塞状态，当任务有空闲的位置，它就会立刻补上空缺位置，然后结束我们的阻塞状态</p><h3 id="实验二：实验一基础上修改接收任务等待时间（手动创建队列）"><a href="#实验二：实验一基础上修改接收任务等待时间（手动创建队列）" class="headerlink" title="实验二：实验一基础上修改接收任务等待时间（手动创建队列）"></a>实验二：实验一基础上修改接收任务等待时间（手动创建队列）</h3><p>将接收任务等待时间改为最大（portMAX_DELAY），观察实验现象</p><h3 id="现象：-1"><a href="#现象：-1" class="headerlink" title="现象："></a>现象：</h3><p>队列满了以后，任务一无法发送任务，任务二进入死等状态，然后我们的接收任务可以连续接收到两个数据</p><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>当队列中的数据全部被接收任务取走之后，我们再次按一下按键，我们的接收任务因为无法接收到数据将会进入阻塞状态，并等到我们的队列中有数据，然后才会读取数据结束阻塞状态</p><h3 id="实验三：覆盖和偷看实验"><a href="#实验三：覆盖和偷看实验" class="headerlink" title="实验三：覆盖和偷看实验"></a>实验三：覆盖和偷看实验</h3><p>创建一个长度为一的队列，然后发送任务二发送函数改为覆盖函数，接收函数改为偷窥函数</p><h3 id="现象：-2"><a href="#现象：-2" class="headerlink" title="现象："></a>现象：</h3><p>按一下我们第2个按键，我们的队列内容被覆盖，并且无论我们怎样偷窥我们的数据队列中的数据都不会被清除</p><h3 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h3><p>我们成功覆盖并且偷看到了我们的队列内容，不过这里要注意，我们有一个前提就是必须队列长度为一，并且我们是覆盖原来的数据，所以它不存在有阻塞的情况</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_05</title>
      <link href="/2022/11/12/FreeRTOS-05/"/>
      <url>/2022/11/12/FreeRTOS-05/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章：任务的基本操作"><a href="#第五章：任务的基本操作" class="headerlink" title="第五章：任务的基本操作"></a>第五章：任务的基本操作</h1><p>上节课我们已经为大家讲了任务的状态，以及如何进行转换，本节课就是来进行实操，我们将教大家如何进行创建任务删除任务以及改变任务的状态</p><h2 id="壹：任务的句柄"><a href="#壹：任务的句柄" class="headerlink" title="壹：任务的句柄"></a><strong>壹：任务的句柄</strong></h2><p>这里需要给大家先介绍一下这个概念也就是我们任务的句柄，相信我们在创建任务的时候就有提到过我们的参数一共有6个，最后一个参数是任务句柄参数（简称：<strong>TCB</strong>）<em>TaskControlBlock</em></p><p>复杂的东西咱们也不去讲，我们每个任务都有那么一大串东西，然后肯定需要用一个东西去管理它，然后我们的任务句柄就是起到这个这个作用的，你可以把它理解为一个指针指向了我们的那个任务，然后我们可以通过他找到我们的任务，去管理我们的任务</p><p>我们创建任务的时候把它赋给了一个句柄，然后我们的这个句柄就可以管理我们的这个任务，在我们删除暂停等一系列操作的时候，我们都可以直接传入，我们的这个句柄就可以达到我们的目的</p><h2 id="贰：任务的基本操作展示"><a href="#贰：任务的基本操作展示" class="headerlink" title="贰：任务的基本操作展示"></a><strong>贰：任务的基本操作展示</strong></h2><h3 id="我们将用到的基本函数："><a href="#我们将用到的基本函数：" class="headerlink" title="我们将用到的基本函数："></a>我们将用到的基本函数：</h3><h3 id="创建任务：xTaskCreate"><a href="#创建任务：xTaskCreate" class="headerlink" title="创建任务：xTaskCreate()"></a><strong>创建任务：</strong>xTaskCreate()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params"> <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为 word</span></span></span><br><span class="line"><span class="params"> <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params"> UBaseType_t uxPriority, <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params"> TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure><h3 id="删除任务：vTaskDelete"><a href="#删除任务：vTaskDelete" class="headerlink" title="删除任务：vTaskDelete()"></a><strong>删除任务：</strong>vTaskDelete()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span><span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_txTaskToDelete)</span>;<span class="comment">//传入任务句柄</span></span><br><span class="line">句柄为<span class="literal">NULL</span>时，删除自己</span><br><span class="line">            为自己时，删除自己</span><br><span class="line">            为其他任务时，删除其他任务</span><br></pre></td></tr></table></figure><h3 id="暂停任务：vTaskSuspend"><a href="#暂停任务：vTaskSuspend" class="headerlink" title="暂停任务：vTaskSuspend()"></a><strong>暂停任务：</strong>vTaskSuspend()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span><span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_txTaskToSuspend)</span>;<span class="comment">//传入任务句柄</span></span><br><span class="line">句柄为<span class="literal">NULL</span>时，暂停自己</span><br><span class="line">            为自己时，暂停自己</span><br><span class="line">            为其他任务时，暂停其他任务</span><br></pre></td></tr></table></figure><h3 id="恢复任务：vTaskResume"><a href="#恢复任务：vTaskResume" class="headerlink" title="恢复任务：vTaskResume()"></a>恢复任务：vTaskResume()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_tvTaskResume)</span>;<span class="comment">//传入任务句柄</span></span><br><span class="line">无法自己恢复自己，因为被暂停的任务是无法执行的</span><br></pre></td></tr></table></figure><h3 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a><strong>其他函数：</strong></h3><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet():"></a>uxTaskPriorityGet():</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( <span class="type">const</span> TaskHandle_t xTask )</span><span class="comment">//传入任务句柄</span></span><br><span class="line">此函数用来获取指定任务的优先级，使用INCLUDE_uxTaskPriorityGet函数的话应该定义为1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vTaskPrioritySet"><a href="#vTaskPrioritySet" class="headerlink" title="vTaskPrioritySet():"></a>vTaskPrioritySet():</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">voidvTaskPrioritySet(xTaskHandle pxTask,unsigned portBASE_TYPEuxNewPriority);</span><br><span class="line">//传入任务句柄，新的优先级</span><br><span class="line">此函数用于改变某一个任务的任务优先级，要使用此函数的话宏INCLUDE_vTaskPrioritySet应该定义为1</span><br></pre></td></tr></table></figure><h4 id="uxTaskGetSystemState"><a href="#uxTaskGetSystemState" class="headerlink" title="uxTaskGetSystemState():"></a>uxTaskGetSystemState():</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t<span class="title function_">uxTaskGetSystemState</span><span class="params">( TaskStatus_t * <span class="type">const</span> pxTaskStatusArray,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> UBaseType_t uxArraySize,</span></span><br><span class="line"><span class="params">                                      <span class="type">uint32_t</span> * <span class="type">const</span> pulTotalRunTime )</span></span><br><span class="line">pxTaskStatusArray： 指向 TaskStatus_t 结构体类型的数组首地址，每个任务至少需要一个TaskStatus_t 结 构 体 ， 任 务 的 数 量 可 以 使 用 函 数<span class="title function_">uxTaskGetNumberOfTasks</span><span class="params">()</span></span><br><span class="line">uxArraySize: 保存任务壮态数组的数组的大小。 </span><br><span class="line">pulTotalRunTime: 如果 configGENERATE_RUN_TIME_STATS 为 1 的话此参数用来保存系统总的运行时间。 </span><br><span class="line">返回值： 统计到的任务壮态的个数，也就是填写到数组 pxTaskStatusArray 中的个数，此值应该等于函数<span class="title function_">uxTaskGetNumberOfTasks</span><span class="params">()</span>的返回值。如果参数uxArraySize 太小的话返回值可能为0</span><br><span class="line"></span><br><span class="line">此函数用于获取系统中所有任务的任务壮态，每个任务的壮态信息保存在一个 TaskStatus_t类型的结构体里面，这个结构体里面包含了任务的任务句柄、任务名字、堆栈、优先级等信息，要使用此函数的话宏 configUSE_TRACE_FACILITY 应该定义为 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有很多就不一一列举了，小伙伴们可以自行查找相关的手册或者其他资料</p><p><img src="/img/blog/image-20220810154552622.png" alt="image-20220810154552622"></p><h3 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h3><p>创建任务一（<u>点亮LED1间隔1000MS闪烁</u> 并且 <u>串口输出传入参数</u>）</p><p>创建任务二（<u>点亮LED2间隔500MS闪烁</u>并且 <u>串口输出传入参数</u>）</p><p>创建任务三（使用KEY1删除和创建任务一）</p><p>创建任务四（使用KEY2暂停和恢复任务二）</p><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>按下KEY1，任务一被删除，再次按下新的任务一被创建</p><p>按下KEY2，任务二被暂停，再次按下任务二恢复执行</p><p><img src="/img/blog/image-20220810161620725.png" alt="image-20220810161620725"></p><h3 id="注意事项：任务被删除句柄并不会被删除，需要手动清空"><a href="#注意事项：任务被删除句柄并不会被删除，需要手动清空" class="headerlink" title="注意事项：任务被删除句柄并不会被删除，需要手动清空"></a>注意事项：任务被删除句柄并不会被删除，需要手动清空</h3>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_04</title>
      <link href="/2022/11/12/FreeRTOS-04/"/>
      <url>/2022/11/12/FreeRTOS-04/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章：任务的状态"><a href="#第四章：任务的状态" class="headerlink" title="第四章：任务的状态"></a>第四章：任务的状态</h1><p>上节课我们提了一嘴FreeRTOS当中的“阻塞模式”，然后本节课将会将这个全部展开讲述一下我们任务的其他的状态，好了话不多说，我们直接开始吧</p><h2 id="壹：状态讲解"><a href="#壹：状态讲解" class="headerlink" title="壹：状态讲解"></a><strong>壹：状态讲解</strong></h2><p>总的来说我们的状态可以分为两种，一种是运行状态，一种是非运行状态</p><h3 id="运行状态（Runing）"><a href="#运行状态（Runing）" class="headerlink" title="运行状态（Runing）"></a>运行状态（Runing）</h3><p>这个应该不需要过多的解释，它就是任务正在运行时候的这个状态被叫做运行状态</p><h3 id="非运行状态（Not-Running）"><a href="#非运行状态（Not-Running）" class="headerlink" title="非运行状态（Not Running）"></a>非运行状态（Not Running）</h3><p>这个并不只是一种运行状态而是好几种状态的统称</p><p>详细的来说它可以分为三种状态分别是：</p><p>阻塞状态(Blocked)、暂停状态(Suspended)、就绪状态(Ready)</p><h4 id="阻塞状态-Blocked-："><a href="#阻塞状态-Blocked-：" class="headerlink" title="阻塞状态(Blocked)："></a>阻塞状态(Blocked)：</h4><p>堵住了，需要等待</p><p>我们可以把执行任务当做一个那个行车的过程，我们的阻塞状态就是我们是进入了<strong>堵车</strong>的情况，然后把道路空出来，就给其它任务去执行了，这样的话我们的其他任务或者说低优先级的任务才有机会执行</p><h4 id="暂停状态-Suspended-："><a href="#暂停状态-Suspended-：" class="headerlink" title="暂停状态(Suspended)："></a>暂停状态(Suspended)：</h4><p>像这种状态一般就是将其手动设置为暂停状态，当他进入暂停状态之后就是真的暂停了，我们不解除暂停状态，他就永远不会执行</p><p>像前面一样，如果把它当做行车的过程的话，就是我们“任务小车”直接离开了车道</p><p><strong>就绪状态(Ready):</strong></p><p>这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态</p><p>像前面一样，如果我们把它当做行车的过程的话，我们的任务小车就是已经具备了行车的条件，但是由于我们的那个灯是红灯，所以还是跑不起来</p><h2 id="贰：状态之间的转换"><a href="#贰：状态之间的转换" class="headerlink" title="贰：状态之间的转换"></a><strong>贰：状态之间的转换</strong></h2><p><img src="/img/blog/image-20220809214843017.png" alt="image-20220809214843017"></p><p>这里是一张我们的那个状态转换的图表</p><h3 id="任务刚创建："><a href="#任务刚创建：" class="headerlink" title="任务刚创建："></a><strong>任务刚创建：</strong></h3><p><img src="/img/blog/image-20220809215014641.png" alt="image-20220809215014641"></p><p>我们任务刚创建的时候，就是这个小黑点，它默认是会直接进入我们的就绪状态，但是它并不会直接运行，一般是在那个调度器启动之后。才会有任务进入运行状态，因为各个任务之间要进行相互的比较和判断，谁可以先执行</p><h5 id="这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，如果同优先级的话，我们一般是后创建的那个任务会先执行"><a href="#这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，如果同优先级的话，我们一般是后创建的那个任务会先执行" class="headerlink" title="这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，如果同优先级的话，我们一般是后创建的那个任务会先执行"></a>这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，<u>如果同优先级的话，我们一般是后创建的那个任务会先执行</u></h5><h3 id="就绪状态："><a href="#就绪状态：" class="headerlink" title="就绪状态："></a><strong>就绪状态：</strong></h3><p><img src="/img/blog/image-20220809215313395.png" alt="image-20220809215313395"></p><p>我们的就绪任务状态就是我们图片中最中央的这个位置，因为通常我们的项目中任务会比较多，但是我们每次只能执行一个任务，这样的话就会有些任务，它具备了执行的条件，但是优先级抢不过其他的任务，他就是就绪状态</p><h3 id="暂停状态："><a href="#暂停状态：" class="headerlink" title="暂停状态："></a><strong>暂停状态：</strong></h3><p><img src="/img/blog/image-20220809215644619.png" alt="image-20220809215644619"></p><p>暂停状态也有人把它叫做我们的悬挂状态，这个状态是一个比较特殊的状态，就是我们直接手动给它叫停了，我们在任何状态下都可以使用对应的函数将其设置为这个暂停状态，这样的话他就永远不会被执行，直到我们将其恢复</p><p>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</p><p>其唯一的进入方法就是使用该函数进入到暂停状态</p><p>void vTaskResume( TaskHandle_t xTaskToResume );</p><p>这个是推出的函数，退出回到就绪状态</p><p>这两个函数传入的参数都是任务的句柄（后续会讲解到！）</p><h3 id="阻塞状态："><a href="#阻塞状态：" class="headerlink" title="阻塞状态："></a><strong>阻塞状态：</strong></h3><p><img src="/img/blog/image-20220809215736225.png" alt="image-20220809215736225"></p><p>这个就是我们的老朋友了，我们使用对应的有阻塞功能的函数，就可以让我们现在的任务进行短时间的阻塞，然后把我们那个任务的执行权交给已经在就绪状态的任务，让他有时间去执行</p><p>一般情况进入阻塞状态的两个函数：</p><p>voidvTaskDelay( const TickType_t xTicksToDelay ); </p><p>第1个函数它就比较简单，就非常像我们的HAL_Delay()函数。然后它里面传入的是我们的那个需要堵塞tick数,然后这个tick，就是指我们的那个节拍单位默认就是毫秒嘛，所以默认情况下它就是和我们的这个HAL_Delay是没有很大区别的，只不过还有HAL_Delay就是在空跑程序，而我们的这个是让它进入了阻塞的状态</p><p>BaseType_txTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement );</p><table><thead><tr><th>参数</th><th align="center">说明</th></tr></thead><tbody><tr><td>pxPreviousWakeTime</td><td align="center">指针，指向一个变量(指针说明这个变量即可以当做输入类型的，也可以当做输出类型的)。该变量保存任务最后一次解除阻塞的时间。第一次使用前，该变量必须初始化为当前时间。之后这个变量会在vTaskDelayUntil()函数内自动更新</td></tr><tr><td>xTimeIncrement</td><td align="center">周期循环时间。当时间等于(*pxPreviousWakeTime + xTimeIncrement)时，任务解除阻塞。如果不改变参数xTimeIncrement的值，调用该函数的任务会按照固定频率执行</td></tr></tbody></table><p>如果指定的唤醒时间已经达到，vTaskDelayUntil()立刻返回（不会有阻塞）。因此，使用vTaskDelayUntil()周期性执行的任务，无论任何原因（比如，任务临时进入挂起状态）停止了周期性执行，使得任务少运行了一个或多个执行周期，那么需要重新计算所需要的唤醒时间。这可以通过传递给函数的指针参数pxPreviousWake指向的值与当前系统时钟计数值比较来检测，在大多数情况下，这并不是必须的</p><p><strong>一般情况下，我们将第1个延时函数叫做相对时间延时，然后第2个叫做绝对时间延时</strong></p><h2 id="叁：两个延时函数的验证"><a href="#叁：两个延时函数的验证" class="headerlink" title="叁：两个延时函数的验证"></a>叁：<strong>两个延时函数的验证</strong></h2><p>然后这一小节我们将会在我们的项目中给大家验证一下，两个延时函数它的区别，带大家认识一下相对延时和绝对延时</p><h3 id="相对延时："><a href="#相对延时：" class="headerlink" title="相对延时："></a>相对延时：</h3><h4 id="是指两次任务执行的间隔时间是相对的（延时时间-x3D-任务执行时间-需要延时的时间）"><a href="#是指两次任务执行的间隔时间是相对的（延时时间-x3D-任务执行时间-需要延时的时间）" class="headerlink" title="是指两次任务执行的间隔时间是相对的（延时时间&#x3D;任务执行时间+需要延时的时间）"></a>是指两次任务执行的间隔时间是相对的（延时时间&#x3D;任务执行时间+需要延时的时间）</h4><h3 id="绝对延时："><a href="#绝对延时：" class="headerlink" title="绝对延时："></a>绝对延时：</h3><h4 id="是指两次任务执行的间隔时间是绝对的（延时时间-x3D-需要延时的时间）"><a href="#是指两次任务执行的间隔时间是绝对的（延时时间-x3D-需要延时的时间）" class="headerlink" title="是指两次任务执行的间隔时间是绝对的（延时时间&#x3D;需要延时的时间）"></a>是指两次任务执行的间隔时间是绝对的（延时时间&#x3D;需要延时的时间）</h4><h3 id="验证方法："><a href="#验证方法：" class="headerlink" title="验证方法："></a>验证方法：</h3><h4 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h4><p>Task1使用相对延时500MS，Task2使用绝对延时500MS，使用HAL_Dlay(200)模拟任务占用时间，观察现象结果</p><h4 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h4><p><img src="/img/blog/image-20220810101815557.png" alt="image-20220810101815557"></p><p>任务一延时了700ms左右，</p><p>任务二演示了较为准确的500MS</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_03</title>
      <link href="/2022/11/12/FreeRTOS-03/"/>
      <url>/2022/11/12/FreeRTOS-03/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章：FreeRTOS优先级讲解"><a href="#第三章：FreeRTOS优先级讲解" class="headerlink" title="第三章：FreeRTOS优先级讲解"></a>第三章：FreeRTOS优先级讲解</h1><p>我们的日常生活中干什么事情也会有一个轻重缓急，而我们的操作系统同样的它也会有一个轻重缓急，也就是优先级</p><p>也就是我们前面创建任务给定的优先级</p><p>​xTaskCreate(vTask1,”LED1”,128,NULL,1,NULL);</p><p>其中第五个参数，就是我们的优先级，默认情况下其范围是0~(configMAX_PRIORITIES – 1)（configMAX_PRIORITIES &#x3D;32），绝大多数情况下，他都是够用的，毕竟我们的操作系统是支持同优先级的</p><p><strong>这里提一嘴，理论上我们的FreeRTOS，如果仅通过软件层面上是可以实现无穷多个优先级的，但是这里结合了我们架构相关的东西，默认他最大只支持32级，这里大概了解一下就可以了，反正正常情况下我们是用不到那么多优先级的</strong></p><p>这里还需要和小伙伴们讲一下我们的FreeRTOS的任务执行原则</p><h2 id="壹：FreeRTOS执行任务的原则："><a href="#壹：FreeRTOS执行任务的原则：" class="headerlink" title="壹：FreeRTOS执行任务的原则："></a>壹：<strong>FreeRTOS执行任务的原则：</strong></h2><h3 id="默认情况为：使用时间片抢占式任务调度（合作式调度模式）"><a href="#默认情况为：使用时间片抢占式任务调度（合作式调度模式）" class="headerlink" title="默认情况为：使用时间片抢占式任务调度（合作式调度模式）"></a>默认情况为：<u>使用时间片抢占式任务调度</u>（合作式调度模式）</h3><h4 id="合作式任务调度解析："><a href="#合作式任务调度解析：" class="headerlink" title="合作式任务调度解析："></a>合作式任务调度解析：</h4><p>仅作了解即可，使用此种调度方式时，我们的FreeRTOS不会主动去进行任务的切换，而是当任务进行阻塞状态时，才会有那个任务的切换</p><p>合作式调度模式几乎不会用到，系统也没有相应的更新维护了</p><h4 id="抢占式任务调度解析："><a href="#抢占式任务调度解析：" class="headerlink" title="抢占式任务调度解析："></a>抢占式任务调度解析：</h4><p>各个任务执行的时候，就像我们裸机开发中的中断一样，是需要去抢这个名额，才能有机会执行，永远先执行优先级最高的任务，优先级最高的任务执行完了才有机会让低等级的任务去执行</p><h5 id="第一原则：永远先执行优先级最高的任务"><a href="#第一原则：永远先执行优先级最高的任务" class="headerlink" title="第一原则：永远先执行优先级最高的任务"></a><u><strong>第一原则：永远先执行优先级最高的任务</strong></u></h5><p>抢占式调度任务又可以分为以下两种：</p><h5 id="使用时间片的抢占式调度方法："><a href="#使用时间片的抢占式调度方法：" class="headerlink" title="使用时间片的抢占式调度方法："></a>使用时间片的抢占式调度方法：</h5><p><strong>同优先级的情况下</strong>，我们每一个时间片他都会去判断一下要不要切换任务或者说<strong>会主动去切换任务</strong></p><h5 id="不使用时间片的抢占式调度方法："><a href="#不使用时间片的抢占式调度方法：" class="headerlink" title="不使用时间片的抢占式调度方法："></a>不使用时间片的抢占式调度方法：</h5><p><strong>同优先级的情况下</strong>，将不会去判断一下要不要切换任务或者说<strong>不会主动切换任务</strong></p><h2 id="贰：FreeRTOS优先级示例分析："><a href="#贰：FreeRTOS优先级示例分析：" class="headerlink" title="贰：FreeRTOS优先级示例分析："></a>贰：<strong>FreeRTOS</strong>优先级示例分析：</h2><p>这里的示例都是默认配置下去验证的（<strong>使用时间片抢占式任务调度</strong>）并且使用的是上一章相同例程</p><h3 id="①：同优先级两个任务"><a href="#①：同优先级两个任务" class="headerlink" title="①：同优先级两个任务"></a>①：同优先级两个任务</h3><h4 id="现象：两个任务都正常运行，不会有干扰"><a href="#现象：两个任务都正常运行，不会有干扰" class="headerlink" title="现象：两个任务都正常运行，不会有干扰"></a>现象：两个任务都正常运行，不会有干扰</h4><h4 id="分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换"><a href="#分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换" class="headerlink" title="分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换"></a>分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换</h4><h3 id="②：LED1优先级高于LED2"><a href="#②：LED1优先级高于LED2" class="headerlink" title="②：LED1优先级高于LED2"></a>②：LED1优先级高于LED2</h3><h4 id="现象：只有LED1任务在执行，LED2任务无法正常执行"><a href="#现象：只有LED1任务在执行，LED2任务无法正常执行" class="headerlink" title="现象：只有LED1任务在执行，LED2任务无法正常执行"></a>现象：只有LED1任务在执行，LED2任务无法正常执行</h4><h4 id="分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的第一原则：永远先执行优先级最高的任务所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行"><a href="#分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的第一原则：永远先执行优先级最高的任务所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行" class="headerlink" title="分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的第一原则：永远先执行优先级最高的任务所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行"></a>分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的<u><strong>第一原则：永远先执行优先级最高的任务</strong></u>所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行</h4><h3 id="③：再②的基础上将Task1中的HAL-Delay-换为vTskDelay-osDelay"><a href="#③：再②的基础上将Task1中的HAL-Delay-换为vTskDelay-osDelay" class="headerlink" title="③：再②的基础上将Task1中的HAL_Delay()换为vTskDelay()[osDelay()]"></a>③：再②的基础上将Task1中的HAL_Delay()换为vTskDelay()[osDelay()]</h3><h4 id="现象：任务正常运行，现象和①一样"><a href="#现象：任务正常运行，现象和①一样" class="headerlink" title="现象：任务正常运行，现象和①一样"></a>现象：任务正常运行，现象和①一样</h4><h4 id="分析：vTskDelay-osDelay-有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会"><a href="#分析：vTskDelay-osDelay-有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会" class="headerlink" title="分析：vTskDelay()[osDelay()]有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会"></a>分析：vTskDelay()[osDelay()]有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会</h4><p>剧透一下，这种状态，叫做“阻塞”，顾名思义使用以后会进入一种堵车的状态，就比如说我们的vTskDelay(1000);就是堵车了一秒，这一秒钟的任务执行权力就被放开了，这样的话我们的低优先级的任务才有机会进行</p><p>好了，本期视频的内容就是这些，我们下一章节就会开始讲一下我们任务的各种状态</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_02</title>
      <link href="/2022/11/12/FreeRTOS-02/"/>
      <url>/2022/11/12/FreeRTOS-02/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：FreeRTOS的移植以及做基本的使用"><a href="#第二章：FreeRTOS的移植以及做基本的使用" class="headerlink" title="第二章：FreeRTOS的移植以及做基本的使用"></a>第二章：FreeRTOS的移植以及做基本的使用</h1><p>本节课我们将会带着大家进行我们的FreeRTOS的移植，本节课主要是实际操作，而且刚开始学习的话，暂时不用过于纠结原理，FreeRTOS只是一个使用的工具我们应该学习的是如何去使用，就像学习我们的STM32一样，先把项目建立出来，让我们LED亮起来再去研究原理和代码</p><h2 id="壹：FreeRTOS的手动移植"><a href="#壹：FreeRTOS的手动移植" class="headerlink" title="壹：FreeRTOS的手动移植"></a><strong>壹：FreeRTOS的手动移植</strong></h2><p>这里我们将会教大家 如何进行我们手动的项目移植</p><h3 id="①-建立STM32的空项目"><a href="#①-建立STM32的空项目" class="headerlink" title="①.建立STM32的空项目"></a>①.建立STM32的空项目</h3><p>这里使用STM32CubeMX快速创建项目，要注意的是我们完成最基本的配置以后，需要将我们的Timebase Source修改一下，修改成除了滴答滴答定时器的其他定时器，就像这样</p><p><img src="/img/blog/image-20220807234427467.png" alt="image-20220807234427467"></p><p>这里我使用的TIM2作为Timebase Source</p><h4 id="为什么不可以使用滴答定时器呢？"><a href="#为什么不可以使用滴答定时器呢？" class="headerlink" title="|为什么不可以使用滴答定时器呢？"></a>|<strong>为什么不可以使用滴答定时器呢？</strong></h4><p>在FreeRTOS中我们的SysTick定时器被用于了我们的始终基准，它用来实现我们的仍无切换，我们的SysTick定时器每次触发我们的中断（默认是一毫秒，可以自行修改为其他值）</p><h4 id="Timebase-Source是干嘛的呢？"><a href="#Timebase-Source是干嘛的呢？" class="headerlink" title="|Timebase Source是干嘛的呢？"></a>|Timebase Source是干嘛的呢？</h4><p>简单的说，正常裸机开发中我们的SysTick定时器是用来主要是用来进行我们的HAL_Delay()延时的，使用其作为基准，前面我们说了SysTick定时器被用于系统任务切换了，所以它就是一直在工作，或者说一直在触发中断，这样的话我们的HAL_Delay()就需用使用我们的其他定时器进行替代其作用了</p><p>为了方便移植展示，这里就生成一个Keil的项目吧！</p><h3 id="②-FreeRTOS内核下载"><a href="#②-FreeRTOS内核下载" class="headerlink" title="②.FreeRTOS内核下载"></a>②.FreeRTOS内核下载</h3><p>以我们自己的能力肯定是不可能自己写出来操作系统的，这一步将会教大家如何去下载FreeRTOS内核以及如何进行移植到我们的项目里面</p><h4 id="进入FreeRTOS的官网"><a href="#进入FreeRTOS的官网" class="headerlink" title="|进入FreeRTOS的官网"></a>|进入FreeRTOS的官网</h4><p>可以选择百度直接搜索FreeRTOS</p><p><img src="/img/blog/image-20220808155909183.png" alt="image-20220808155909183"></p><p>然后选择</p><p><img src="/img/blog/image-20220808155935717.png" alt="image-20220808155935717"></p><p>也可以直接点击该链接进入</p><p><a href="https://www.freertos.org/">https://www.freertos.org/</a></p><p>然后点击右上角下载FreeRTOS</p><p><img src="/img/blog/image-20220808160040097.png" alt="image-20220808160040097"></p><p>来到版本选择界面</p><p><img src="/img/blog/image-20220808160125937.png" alt="image-20220808160125937"></p><p>上面的是FreeRTOS的最新版本，下面的就是长期维护的版本</p><p>我们直接点击上面这个Github的超链接</p><p><img src="/img/blog/image-20220808161616625.png" alt="image-20220808161616625"></p><p>然后就依次带点击Code和Download ZIP</p><p><img src="/img/blog/image-20220808161844246.png" alt="image-20220808161844246"></p><p>不过我发现，这个下载下来好像是不完整的</p><p><img src="/img/blog/image-20220808161954743.png" alt="image-20220808161954743"></p><p>这里也写了它的子模块是不会直接下载进去的，这里我们就需要继续往下翻</p><p><img src="/img/blog/image-20220808162132172.png" alt="image-20220808162132172"></p><p>翻译过来就是这样的</p><p><img src="/img/blog/image-20220808162148237.png" alt="image-20220808162148237"></p><p>内核代码在这里我们点击超链接，同样的方法进行下载</p><p>这里就快速掠过，如果无法下载应该就是网络问题了</p><p>下载好，然后进行一下解压</p><p><img src="/img/blog/image-20220808174843292.png" alt="image-20220808174843292"></p><p>解压好了就是这个样子</p><p>FreeRTOS-Kernel是FreeRTOS的内核文件</p><p>FreeRTOS-main里面文件很多，我们主要是看里面的Demo</p><p><img src="/img/blog/image-20220808175037048.png" alt="image-20220808175037048"></p><p>然后接着点击<img src="/img/blog/image-20220808175057051.png" alt="image-20220808175057051"></p><p>里面的文件非常多，不过我们可以找到这样一个文件夹</p><p><img src="/img/blog/image-20220808175154467.png" alt="image-20220808175154467"></p><p>这里有系统已经移植好的实例，但是这并不是我们直接移植的，感兴趣的小伙伴可以先打看官方移植好的能不能看懂</p><h3 id="③-手动移植FreeRTOS内核文件"><a href="#③-手动移植FreeRTOS内核文件" class="headerlink" title="③.手动移植FreeRTOS内核文件"></a>③.手动移植FreeRTOS内核文件</h3><h4 id="1-打开第一步建立的新项目"><a href="#1-打开第一步建立的新项目" class="headerlink" title="1.打开第一步建立的新项目"></a>1.打开第一步建立的新项目</h4><h4 id="2-左侧项目文件添加两个新的分组"><a href="#2-左侧项目文件添加两个新的分组" class="headerlink" title="2.左侧项目文件添加两个新的分组"></a>2.左侧项目文件添加两个新的分组</h4><p><img src="/img/blog/image-20220808180601576.png" alt="image-20220808180601576"></p><h4 id="3-建立对应的FreeRTOS文件夹"><a href="#3-建立对应的FreeRTOS文件夹" class="headerlink" title="3.建立对应的FreeRTOS文件夹"></a>3.建立对应的FreeRTOS文件夹</h4><p><img src="/img/blog/image-20220808181508665.png" alt="image-20220808181508665"></p><h4 id="4-打开FreeRTOS-Kernel文件夹"><a href="#4-打开FreeRTOS-Kernel文件夹" class="headerlink" title="4.打开FreeRTOS-Kernel文件夹"></a>4.打开FreeRTOS-Kernel文件夹</h4><h4 id="5-主目录下所有的-C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）"><a href="#5-主目录下所有的-C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）" class="headerlink" title="5.主目录下所有的.C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）"></a>5.主目录下所有的.C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）</h4><p><img src="/img/blog/image-20220808181613953.png" alt="image-20220808181613953"></p><h4 id="6-复制include文件夹以及portable文件夹到FreeRTOS文件夹下"><a href="#6-复制include文件夹以及portable文件夹到FreeRTOS文件夹下" class="headerlink" title="6.复制include文件夹以及portable文件夹到FreeRTOS文件夹下"></a>6.复制include文件夹以及portable文件夹到FreeRTOS文件夹下</h4><p><img src="/img/blog/image-20220808181838922.png" alt="image-20220808181838922"></p><h4 id="7-保留FreeRTOS-x2F-portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除"><a href="#7-保留FreeRTOS-x2F-portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除" class="headerlink" title="7.保留FreeRTOS&#x2F;portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除"></a>7.保留FreeRTOS&#x2F;portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除</h4><p><img src="/img/blog/image-20220808182219502.png" alt="image-20220808182219502"></p><h4 id="8-保留FreeRTOS-x2F-portable-x2F-RVDS文件夹中的ARM-CM3文件夹"><a href="#8-保留FreeRTOS-x2F-portable-x2F-RVDS文件夹中的ARM-CM3文件夹" class="headerlink" title="8.保留FreeRTOS&#x2F;portable&#x2F;RVDS文件夹中的ARM_CM3文件夹"></a>8.保留FreeRTOS&#x2F;portable&#x2F;RVDS文件夹中的ARM_CM3文件夹</h4><p><img src="/img/blog/image-20220808182339598.png" alt="image-20220808182339598"></p><h4 id="9-然后如图进行Keil项目的分组文件配置"><a href="#9-然后如图进行Keil项目的分组文件配置" class="headerlink" title="9.然后如图进行Keil项目的分组文件配置"></a>9.然后如图进行Keil项目的分组文件配置</h4><p><img src="/img/blog/image-20220808182506735.png" alt="image-20220808182506735"></p><p><img src="/img/blog/image-20220808182619420.png" alt="image-20220808182619420"></p><h4 id="10-添加对应的头文件"><a href="#10-添加对应的头文件" class="headerlink" title="10.添加对应的头文件"></a>10.添加对应的头文件</h4><p><img src="/img/blog/image-20220808182744742.png" alt="image-20220808182744742"></p><h4 id="11-直接编译（出现9个错误）"><a href="#11-直接编译（出现9个错误）" class="headerlink" title="11.直接编译（出现9个错误）"></a>11.直接编译（出现9个错误）</h4><p><img src="/img/blog/image-20220808183013851.png" alt="image-20220808183013851"></p><h3 id="④-项目问题修复"><a href="#④-项目问题修复" class="headerlink" title="④.项目问题修复"></a>④.项目问题修复</h3><h4 id="缺少FreeRTOSConfig-h文件（FreeRTOS的配置文件）"><a href="#缺少FreeRTOSConfig-h文件（FreeRTOS的配置文件）" class="headerlink" title="|缺少FreeRTOSConfig.h文件（FreeRTOS的配置文件）"></a>|缺少FreeRTOSConfig.h文件（FreeRTOS的配置文件）</h4><p><img src="/img/blog/image-20220808183724419.png" alt="image-20220808183724419"></p><h4 id="示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）"><a href="#示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）" class="headerlink" title="|示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）"></a>|示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）</h4><p><img src="/img/blog/image-20220808183808327.png" alt="image-20220808183808327"></p><p><img src="/img/blog/image-20220808183927543.png" alt="image-20220808183927543"></p><h4 id="编译，还是报错"><a href="#编译，还是报错" class="headerlink" title="|编译，还是报错"></a>|编译，还是报错</h4><p><img src="/img/blog/image-20220808184017777.png" alt="image-20220808184017777"></p><h4 id="在FreeRTOSConfig-h中添加-defineINCLUDE-xTaskGetCurrentTaskHandle1"><a href="#在FreeRTOSConfig-h中添加-defineINCLUDE-xTaskGetCurrentTaskHandle1" class="headerlink" title="|在FreeRTOSConfig.h中添加#defineINCLUDE_xTaskGetCurrentTaskHandle1"></a>|在FreeRTOSConfig.h中添加#defineINCLUDE_xTaskGetCurrentTaskHandle1</h4><h4 id="编译无错误"><a href="#编译无错误" class="headerlink" title="|编译无错误"></a>|编译无错误</h4><p><img src="/img/blog/image-20220808191109640.png" alt="image-20220808191109640"></p><h3 id="⑤-项目添加处理"><a href="#⑤-项目添加处理" class="headerlink" title="⑤.项目添加处理"></a>⑤.项目添加处理</h3><p>虽然没有错误了，但是我们的移植没有完成，还有一些小步骤需要完成，的确有些繁琐，好在逻辑性还是比较强的，理解起来相对容易</p><h4 id="在FreeRTOSConfig-h中添加-definexPortPendSVHandlerPendSV-Handler"><a href="#在FreeRTOSConfig-h中添加-definexPortPendSVHandlerPendSV-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definexPortPendSVHandlerPendSV_Handler"></a>|在FreeRTOSConfig.h中添加#definexPortPendSVHandlerPendSV_Handler</h4><h4 id="在FreeRTOSConfig-h中添加-definexPortSysTickHandlerSysTick-Handler"><a href="#在FreeRTOSConfig-h中添加-definexPortSysTickHandlerSysTick-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definexPortSysTickHandlerSysTick_Handler"></a>|在FreeRTOSConfig.h中添加#definexPortSysTickHandlerSysTick_Handler</h4><h4 id="在FreeRTOSConfig-h中添加-definevPortSVCHandlerSVC-Handler"><a href="#在FreeRTOSConfig-h中添加-definevPortSVCHandlerSVC-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definevPortSVCHandlerSVC_Handler"></a>|在FreeRTOSConfig.h中添加#definevPortSVCHandlerSVC_Handler</h4><p>左边三个是我们Free RTOS中定义好的函数，右边的是系统项目本来就定义好的函数，他们的作用小伙伴们可以去了解一下，作为初学者这里不进行拓展，反正就是和我们操作系统的中断还有任务切换有关的函数</p><h4 id="编译，还是报错，重复定义"><a href="#编译，还是报错，重复定义" class="headerlink" title="|编译，还是报错，重复定义"></a>|编译，还是报错，重复定义</h4><p><img src="/img/blog/image-20220808193114683.png" alt="image-20220808193114683"></p><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="|处理错误"></a>|处理错误</h4><h4 id="进入对应的文件stm32f1xx-it-c删除重复的3个函数"><a href="#进入对应的文件stm32f1xx-it-c删除重复的3个函数" class="headerlink" title="|进入对应的文件stm32f1xx_it.c删除重复的3个函数"></a>|进入对应的文件stm32f1xx_it.c删除重复的3个函数</h4><h4 id="OK啦！"><a href="#OK啦！" class="headerlink" title="|OK啦！"></a>|OK啦！</h4><h3 id="⑥-FreeRTOS点灯项目创建"><a href="#⑥-FreeRTOS点灯项目创建" class="headerlink" title="⑥.FreeRTOS点灯项目创建"></a>⑥.FreeRTOS点灯项目创建</h3><p>弄了这么久，终于移植完成了，我们现在开始创建我们的任务吧！</p><p>首先回到项目中我们需要</p><h4 id="相关的头文件引入"><a href="#相关的头文件引入" class="headerlink" title="相关的头文件引入"></a><strong>相关的头文件引入</strong></h4><p>用到的头文件有<br>“FreeRTOS.h”（操作系统相关）</p><p>“task.h”（任务相关）</p><p><img src="/img/blog/image-20220808205027644.png" alt="image-20220808205027644"></p><h4 id="任务函数创建"><a href="#任务函数创建" class="headerlink" title="任务函数创建"></a><strong>任务函数创建</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,<span class="number">0</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,<span class="number">1</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,<span class="number">0</span>);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,<span class="number">1</span>);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主函数创建任务，以及开启任务调度器"><a href="#主函数创建任务，以及开启任务调度器" class="headerlink" title="主函数创建任务，以及开启任务调度器"></a><strong>主函数创建任务，以及开启任务调度器</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    <span class="comment">//创建任务1</span></span><br><span class="line">xTaskCreate(vTask1,<span class="string">&quot;LED1&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建任务2</span></span><br><span class="line">xTaskCreate(vTask2,<span class="string">&quot;LED2&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//启动任务调度器</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦-程序烧录到开发板查看效果"><a href="#⑦-程序烧录到开发板查看效果" class="headerlink" title="⑦.程序烧录到开发板查看效果"></a>⑦.程序烧录到开发板查看效果</h3><p>编译项目，然后进行简单的烧录，并且查看效果</p><h2 id="贰：CubeMX快速生成FreeRTOS项目"><a href="#贰：CubeMX快速生成FreeRTOS项目" class="headerlink" title="贰：CubeMX快速生成FreeRTOS项目"></a><strong>贰：CubeMX快速生成FreeRTOS项目</strong></h2><p>前面我们已经成功手动移植了我们的FreeRTOS的操作系统，步骤相对来说还是比较繁琐的，在我们的开发中肯定不可能每次都去这样的移植，所以我们本期视频就是教大家一个更快捷高效的方法，也就是使用我们的CubeMX快速生产FreeRTOS的项目，并且达到我们上期视频同样的效果，好了我们现在开始，这里我将会使用CubeIDE来生成项目</p><h3 id="①正常流程初始化项目"><a href="#①正常流程初始化项目" class="headerlink" title="①正常流程初始化项目"></a>①正常流程初始化项目</h3><p>我们就按照平常初始化项目，把我们的时钟频率设置好以及我们上节课讲到了基本时钟源改为其他的定时器</p><p><img src="/img/blog/image-20220809090154611.png" alt="image-20220809090154611"></p><p><img src="/img/blog/image-20220809090213133.png" alt="image-20220809090213133"></p><h3 id="②找到Middleware选项然后点击FREERTOS"><a href="#②找到Middleware选项然后点击FREERTOS" class="headerlink" title="②找到Middleware选项然后点击FREERTOS"></a>②找到Middleware选项然后点击FREERTOS</h3><p><img src="/img/blog/image-20220809090351242.png" alt="image-20220809090351242"></p><h3 id="③选择CMSIS-V1"><a href="#③选择CMSIS-V1" class="headerlink" title="③选择CMSIS_V1"></a>③选择CMSIS_V1</h3><h4 id="版本解释"><a href="#版本解释" class="headerlink" title="版本解释"></a>版本解释</h4><p>V1的这个版本是老版本，然后V2版本是新版本，其实区别没有很大版本也没有差很多，不过相对来说我们直接选择V1就可以了，因为使用的人是比较多的</p><h3 id="④参数介绍"><a href="#④参数介绍" class="headerlink" title="④参数介绍"></a>④参数介绍</h3><p><img src="/img/blog/image-20220809090701721.png" alt="image-20220809090701721"></p><p>可以看到我们需要设置的参数是非常非常多的，这里阿熊就给大家简单的解释一些常用的后续碰到会陆续的进行解释</p><h4 id="Config-parameters（配置参数）"><a href="#Config-parameters（配置参数）" class="headerlink" title="Config parameters（配置参数）"></a>Config parameters（配置参数）</h4><p><img src="/img/blog/image-20220809090918763.png" alt="image-20220809090918763"></p><p>这里就是我们Free RTOS的配置参数，可以选择性的开启或者关闭某些功能，我们前面有讲过FreeRTOS的可裁剪性，是它的一大优势，像我们的这些设置里就是开启或关闭它的一些功能</p><h4 id="Include-parameters（内部参数）"><a href="#Include-parameters（内部参数）" class="headerlink" title="Include parameters（内部参数）"></a>Include parameters（内部参数）</h4><p><img src="/img/blog/image-20220809091219415.png" alt="image-20220809091219415"></p><p>这里面是我们开发中可能会用到的一些函数，我们如果用不到的话可以就选择性的将其关闭，这样的话我们的内核大小也会减小很多</p><h4 id="Tasks-and-Queues（任务和队列）"><a href="#Tasks-and-Queues（任务和队列）" class="headerlink" title="Tasks and Queues（任务和队列）"></a>Tasks and Queues（任务和队列）</h4><p><img src="/img/blog/image-20220809091405056.png" alt="image-20220809091405056"></p><p>我们操作系统中的任务还有我们的队列（后续会介绍到）都是可以直接在这里进行一个初始化的，我们只需要去更新内部的函数内容就可以高效的完成我们的项目</p><h4 id="Other（其他设置）"><a href="#Other（其他设置）" class="headerlink" title="Other（其他设置）"></a>Other（其他设置）</h4><p>这里我们就只介绍我们的这3个比较重要的，其他的全部统称为其他设置，后续的课程中，我们遇到了再讲解</p><h3 id="⑤添加Task"><a href="#⑤添加Task" class="headerlink" title="⑤添加Task"></a>⑤添加Task</h3><p>直接点击Add或者双击默认的项目</p><p><img src="/img/blog/image-20220809091752257.png" alt="image-20220809091752257"></p><p>其分别对应</p><p>任务名称、任务优先级、任务堆栈大小、进入函数名称、代码生成方式、参数、任务类型</p><h4 id="任务名称："><a href="#任务名称：" class="headerlink" title="任务名称："></a>任务名称：</h4><p>就是单纯的名称，一般随便取一个就好了，没有什么实质性的作用，毕竟我们执行的时候用的是函数名称</p><h4 id="任务优先级："><a href="#任务优先级：" class="headerlink" title="任务优先级："></a>任务优先级：</h4><p>任务优先级就很像我们那个中断优先级，不过它与我们的中断优先级是相反的，我们的中断优先级中的中段是数字越小，然后它的优先级就会越高，我们的操作系统中数字越大，优先级越高，并且会优先执行</p><h4 id="任务堆栈大小："><a href="#任务堆栈大小：" class="headerlink" title="任务堆栈大小："></a>任务堆栈大小：</h4><p>就是可以理解为我们的任务执行所需要的空间大小，太大了不是很好，太小了反而会不够，所以这个需要一定的经验去判断</p><h4 id="进入函数名称："><a href="#进入函数名称：" class="headerlink" title="进入函数名称："></a>进入函数名称：</h4><p>就是我们执行任务时对应的那个函数，它的名称是什么？我们的系统会自动给我们写好一个框架</p><h4 id="任务类型："><a href="#任务类型：" class="headerlink" title="任务类型："></a>任务类型：</h4><p>我们任务生成的类型有动态生成，还有静态生成，动态生成的话就是系统，你只要告诉他空间大小系统会自己划分好，而我们静态生成是直接要指定一块地点，相对来说使用是非常少的，而且作为初学者几乎是完全理解不了的，所以我们本视频系列教程是不会涉及到静态生成任务，只会讲解动态任务</p><h4 id="Other："><a href="#Other：" class="headerlink" title="Other："></a>Other：</h4><p>前面就是我们需要理解的，其他的我们后续遇到了会再讲解</p><h4 id="添加LED的任务："><a href="#添加LED的任务：" class="headerlink" title="添加LED的任务："></a>添加LED的任务：</h4><p><img src="/img/blog/image-20220809092814718.png" alt="image-20220809092814718"></p><p><img src="/img/blog/image-20220809092900372.png" alt="image-20220809092900372"></p><h4 id="保存一下，然后生成项目"><a href="#保存一下，然后生成项目" class="headerlink" title="保存一下，然后生成项目"></a>保存一下，然后生成项目</h4><h3 id="⑥完成任务函数"><a href="#⑥完成任务函数" class="headerlink" title="⑥完成任务函数"></a>⑥完成任务函数</h3><p>可以看到我们生成的项目中，main.C中他并没有那个任务的函数，我们可以找到左边的那个文件管理来，可以找到一个freeRTOS.C的项目文件，然后我们双击打开</p><p><img src="/img/blog/image-20220809093230591.png" alt="image-20220809093230591"></p><p>然后我们就可以快速的完成一下两个任务，上节课视频我们也有讲过，如何去书写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header_LED_Task1 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Function implementing the LED1 thread.</span></span><br><span class="line"><span class="comment">  * @param  argument: Not used</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_LED_Task1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED_Task1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,<span class="number">1</span>);</span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,<span class="number">0</span>);</span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED_Task1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Header_LED_Task2 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Function implementing the LED2 thread.</span></span><br><span class="line"><span class="comment">* @param argument: Not used</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_LED_Task2 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED_Task2 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin,<span class="number">1</span>);</span><br><span class="line">  HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin,<span class="number">0</span>);</span><br><span class="line">  HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED_Task2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦编译，烧录查看现象"><a href="#⑦编译，烧录查看现象" class="headerlink" title="⑦编译，烧录查看现象"></a>⑦编译，烧录查看现象</h3><p>可以看到我们的那个实验现象和上期手动移植的现象是完全一样的，我们成功完成了快速生成FreeRTOS的项目并且完成了最基本的任务</p><h3 id="⑧代码讲解"><a href="#⑧代码讲解" class="headerlink" title="⑧代码讲解"></a>⑧代码讲解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* Call init function for freertos objects (in freertos.c) */</span></span><br><span class="line">  MX_FREERTOS_Init();</span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="comment">/* We should never get here as control is now taken by the scheduler */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数中，我们最开始还是普通的初始化，和我们的普通项目没有区别</p><p>接着是</p><p>MX_FREERTOS_Init();</p><p>我们转跳过去看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Create the thread(s) */</span></span><br><span class="line">  <span class="comment">/* definition and creation of LED1 */</span></span><br><span class="line">  osThreadDef(LED1, LED_Task1, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED1Handle = osThreadCreate(osThread(LED1), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* definition and creation of LED2 */</span></span><br><span class="line">  osThreadDef(LED2, LED_Task2, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED2Handle = osThreadCreate(osThread(LED2), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容也很简单，其实他就是创建了我们的两个项目，然后相对来说小伙伴们可以发现和我们手动一直是不一样的，因为我们的 Free rtos的那个操作系统在我们那个ST官方的那个优化下，他自己将很多函数都进行了重新的宏定义以及方法的改写</p><p>我们甚至可以转跳过去看看他是怎么实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">osThreadId <span class="title function_">osThreadCreate</span> <span class="params">(<span class="type">const</span> osThreadDef_t *thread_def, <span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TaskHandle_t handle;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line">  <span class="keyword">if</span>((thread_def-&gt;buffer != <span class="literal">NULL</span>) &amp;&amp; (thread_def-&gt;controlblock != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              thread_def-&gt;buffer, thread_def-&gt;controlblock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              &amp;handle) != pdPASS)  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span>( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line"></span><br><span class="line">    handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              thread_def-&gt;buffer, thread_def-&gt;controlblock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">                   thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">                   &amp;handle) != pdPASS)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然他看起来很复杂，但是我们几乎可以一眼就找到我们上节课用到的那个xTaskCreate函数</p><p>在我们系统生成的FreeRTOS的框架下，它是宏定义了很多的函数，但其实用法师和我们的没有什么区别，我们甚至可以直接用我们上节课所写的那些东西,也可以实现同样的效果</p><p>这里就不拓展开了，碰到了我们再讲解</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_01</title>
      <link href="/2022/11/12/FreeRTOS-01/"/>
      <url>/2022/11/12/FreeRTOS-01/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：FreeRTOS的简述"><a href="#第一章：FreeRTOS的简述" class="headerlink" title="第一章：FreeRTOS的简述"></a>第一章：FreeRTOS的简述</h1><p>说到FreeRTOS，就不得不先带着大家去了解一下我们的RTOS</p><h2 id="壹：RTOS的简介"><a href="#壹：RTOS的简介" class="headerlink" title="壹：RTOS的简介"></a><strong>壹：RTOS的简介</strong></h2><p>实时操作系统（Real Time Operating System，简称RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点</p><p><a href="https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/357530?fromtitle=RTOS&amp;fromid=987080&amp;fr=aladdin">https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/357530?fromtitle=RTOS&amp;fromid=987080&amp;fr=aladdin</a></p><p>这里有转跳链接，小伙伴们可以转跳过去仔细看看，这里就不过多的赘述，简单的总结如下：</p><p>大体上，实时操作系统（RTOS）要求：</p><ul><li>多任务</li><li>处理能被区分优先次序的进程线</li><li>一个中断水平的充分数量</li></ul><p>被装入作为微型设备一部分的内含小操作系统经常要求实时操作系统。一些核心问题能被考虑以符合实时操作系统的需求。然而，因为像设备驱动程序这样的其他成份，也通常被特别的方法需要，一个实时操作系统通常比核心更大</p><p>RTOS只是一个统称，他可以分为各种各样的版本以及平台，由于RTOS需占用一定的系统资源(尤其是RAM资源)，只有μC&#x2F;OS-II、embOS、salvo、FreeRTOS等少数能在小RAM单片机上运行。相对μC&#x2F;OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行</p><p>然后我们现在来看我们的FreeRTOS</p><h2 id="贰：FreeRTOS的简介"><a href="#贰：FreeRTOS的简介" class="headerlink" title="贰：FreeRTOS的简介"></a><strong>贰：FreeRTOS的简介</strong></h2><p>FreeRTOS是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要</p><p>其功能特点如下：</p><ul><li><strong>用户可配置内核功能(可裁剪)</strong></li><li><strong>多平台的支持</strong></li><li><strong>提供一个高层次的信任代码的完整性</strong></li><li><strong>目标代码小，简单易用</strong></li><li><strong>遵循MISRA-C标准的编程规范</strong></li><li><strong>强大的执行跟踪功能</strong></li><li><strong>堆栈溢出检测</strong></li><li><strong>没有限制的任务数量</strong></li><li><strong>没有限制的任务优先级</strong></li><li><strong>多个任务可以分配相同的优先权</strong></li><li><strong>队列，二进制信号量，计数信号灯和递归通信和同步的任务</strong></li><li><strong>优先级继承</strong></li><li><strong>免费开源的源代码</strong></li></ul><p>并且最重要的一点是支持免费的商用，而且社区环境很好，使用的人很多</p><p><strong>这里有转跳链接，小伙伴们可以转跳过去仔细看看</strong></p><p><a href="https://baike.baidu.com/item/FreeRTOS/9786143?fr=aladdin">https://baike.baidu.com/item/FreeRTOS/9786143?fr=aladdin</a></p><h2 id="叁：多任务操作系统的引入"><a href="#叁：多任务操作系统的引入" class="headerlink" title="叁：多任务操作系统的引入"></a>叁：多任务操作系统的引入</h2><p>说到多任务操作系统，我们就不得不提到我们的裸机开发，裸机开发的话，它并不是相对于多任务操作系统就很弱，他们俩在各自的领域有各自的使用场景，也有各自的优缺点，就比如说我们直接进行裸机开发，它主要是在我们的一个while循环中进行所有的项目操作，有些情况下，会有一个或者多个中断来处理一些突然发生的事或者已经设计好的事情，如果我们仅仅是开发一些小项目或者功能比较单一的项目，裸机是最可靠最有效而且很方便开发的一种模式，但是当我们的项目功能越来越多，我们就要引入多任务的操作系统，多任务操作系统顾名思义就是可以处理很多个任务，就像我们的手机一样，我们的手机后台也是可以挂起多个应用的</p><p>在我们引入操作系统之后，我们就不需要去精心的设计我们的时序流程，因为各个任务之间是不存在相互干扰的，我们只需要使用我们的命令去开启或者关闭某一些任务就可以了，当然这肯定是需要占用一些系统资源的，不过现在的单片机的内存都是足够大的，所以我们一般情况下是不需要担心我们的操作系统内核，而是直接移植进行使用，并且我们的多任务操作系统的思维，就很像我们人去思考的思维更加的方便，而我们的裸机开发更像是机械思维，在开发过程中以及开发流程中操作系统是非常方便使用以及开发的</p><p>我们可以再通俗一点的讲，把我们的单片机当做一台电脑的CPU，就像我们使用的电脑一样，我们在上面安装了windows系统，而我们需要执行的任务，比如说打开QQ或者其他的任务，只需要在操作系统上进行完成就可以了</p><p>说了这么多，相信小伙伴们还是对实际的多任务操作系统还是没什么概念，这里就简单给大家举一个例子</p><p>这里并不会出现源码，只是大概的体现一下RTOS与裸机开发的不同之处</p><p>裸机开发中LED闪烁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    whlie(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LED1置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED1置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是只有一个LED的情况如果有两个LED，一个需要500MS闪烁，一个需要一秒闪烁一次，这样的话我们的代码是不是难度就加大了,好像逻辑就混乱了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    whlie(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LED1置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED1置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED2置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时500MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时500MS</span></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们大脑最希望的添加代码方式，很显然他是错的，两个任务之间产生了相互的影响，使得两个任务都执行错误，很多同学就会说这是阿熊代码的问题，对没错，这种思想在裸机开发中肯定是错的，但是在我们的RTOS中他就可以是对的</p><p><img src="/img/blog/image-20220807151229878.png" alt="1"></p><p>这是我们独立的两个任务内容，我们只需要把他的扔到我们的任务执行器里，他就会“同时”运行了，很多小伙伴就会疑问了，单片机明明只有一个核，为什么可以同时执行多个任务呢？</p><h2 id="肆：任务“同时”执行的原理"><a href="#肆：任务“同时”执行的原理" class="headerlink" title="肆：任务“同时”执行的原理"></a>肆：任务“同时”执行的原理</h2><p>还记得我们51单片机里面讲的8*8LED的点阵吗？</p><p><img src="/img/blog/image-20220807151850554.png" alt="2">)</p><p>就这家伙，还记得他是怎么做到使用16个引脚驱动64个灯的吗？</p><p>视觉暂停，也可以说是“视觉欺骗”，他并不是同时亮起来的，而是一排一排亮起来的，只不过切换的速度太快了，肉眼反应不过来，所以就同时亮起来了</p><p>我们RTOS也差不多是这样，我们可以让我们的每个任务执行一个时间单位，然后就切换到另外一个任务执行一个时间单位，再切换回去，两个任务都是独立运行的，互不影响，由于切换的频率很快，就感觉像是同时运行的一样</p><p><img src="/img/blog/image-20220807161019652.png" alt="3"></p><h1 id="这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮"><a href="#这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮" class="headerlink" title="这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮"></a>这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮</h1><hr>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
