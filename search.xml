<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS_05</title>
      <link href="/2022/11/12/FreeRTOS-05/"/>
      <url>/2022/11/12/FreeRTOS-05/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章：任务的基本操作"><a href="#第五章：任务的基本操作" class="headerlink" title="第五章：任务的基本操作"></a>第五章：任务的基本操作</h1><p>上节课我们已经为大家讲了任务的状态，以及如何进行转换，本节课就是来进行实操，我们将教大家如何进行创建任务删除任务以及改变任务的状态</p><h2 id="壹：任务的句柄"><a href="#壹：任务的句柄" class="headerlink" title="壹：任务的句柄"></a><strong>壹：任务的句柄</strong></h2><p>这里需要给大家先介绍一下这个概念也就是我们任务的句柄，相信我们在创建任务的时候就有提到过我们的参数一共有6个，最后一个参数是任务句柄参数（简称：<strong>TCB</strong>）<em>TaskControlBlock</em></p><p>复杂的东西咱们也不去讲，我们每个任务都有那么一大串东西，然后肯定需要用一个东西去管理它，然后我们的任务句柄就是起到这个这个作用的，你可以把它理解为一个指针指向了我们的那个任务，然后我们可以通过他找到我们的任务，去管理我们的任务</p><p>我们创建任务的时候把它赋给了一个句柄，然后我们的这个句柄就可以管理我们的这个任务，在我们删除暂停等一系列操作的时候，我们都可以直接传入，我们的这个句柄就可以达到我们的目的</p><h2 id="贰：任务的基本操作展示"><a href="#贰：任务的基本操作展示" class="headerlink" title="贰：任务的基本操作展示"></a><strong>贰：任务的基本操作展示</strong></h2><h3 id="我们将用到的基本函数："><a href="#我们将用到的基本函数：" class="headerlink" title="我们将用到的基本函数："></a>我们将用到的基本函数：</h3><h3 id="创建任务：xTaskCreate"><a href="#创建任务：xTaskCreate" class="headerlink" title="创建任务：xTaskCreate()"></a><strong>创建任务：</strong>xTaskCreate()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t<span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params"> <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为 word</span></span></span><br><span class="line"><span class="params"> <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params"> UBaseType_t uxPriority, <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params"> TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure><h3 id="删除任务：vTaskDelete"><a href="#删除任务：vTaskDelete" class="headerlink" title="删除任务：vTaskDelete()"></a><strong>删除任务：</strong>vTaskDelete()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span><span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_txTaskToDelete)</span>;<span class="comment">//传入任务句柄</span></span><br><span class="line">句柄为<span class="literal">NULL</span>时，删除自己</span><br><span class="line">            为自己时，删除自己</span><br><span class="line">            为其他任务时，删除其他任务</span><br></pre></td></tr></table></figure><h3 id="暂停任务：vTaskSuspend"><a href="#暂停任务：vTaskSuspend" class="headerlink" title="暂停任务：vTaskSuspend()"></a><strong>暂停任务：</strong>vTaskSuspend()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span><span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_txTaskToSuspend)</span>;<span class="comment">//传入任务句柄</span></span><br><span class="line">句柄为<span class="literal">NULL</span>时，暂停自己</span><br><span class="line">            为自己时，暂停自己</span><br><span class="line">            为其他任务时，暂停其他任务</span><br></pre></td></tr></table></figure><h3 id="恢复任务：vTaskResume"><a href="#恢复任务：vTaskResume" class="headerlink" title="恢复任务：vTaskResume()"></a>恢复任务：vTaskResume()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_tvTaskResume)</span>;<span class="comment">//传入任务句柄</span></span><br><span class="line">无法自己恢复自己，因为被暂停的任务是无法执行的</span><br></pre></td></tr></table></figure><h3 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a><strong>其他函数：</strong></h3><h4 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet():"></a>uxTaskPriorityGet():</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( <span class="type">const</span> TaskHandle_t xTask )</span><span class="comment">//传入任务句柄</span></span><br><span class="line">此函数用来获取指定任务的优先级，使用INCLUDE_uxTaskPriorityGet函数的话应该定义为1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vTaskPrioritySet"><a href="#vTaskPrioritySet" class="headerlink" title="vTaskPrioritySet():"></a>vTaskPrioritySet():</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">voidvTaskPrioritySet(xTaskHandle pxTask,unsigned portBASE_TYPEuxNewPriority);</span><br><span class="line">//传入任务句柄，新的优先级</span><br><span class="line">此函数用于改变某一个任务的任务优先级，要使用此函数的话宏INCLUDE_vTaskPrioritySet应该定义为1</span><br></pre></td></tr></table></figure><h4 id="uxTaskGetSystemState"><a href="#uxTaskGetSystemState" class="headerlink" title="uxTaskGetSystemState():"></a>uxTaskGetSystemState():</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t<span class="title function_">uxTaskGetSystemState</span><span class="params">( TaskStatus_t * <span class="type">const</span> pxTaskStatusArray,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> UBaseType_t uxArraySize,</span></span><br><span class="line"><span class="params">                                      <span class="type">uint32_t</span> * <span class="type">const</span> pulTotalRunTime )</span></span><br><span class="line">pxTaskStatusArray： 指向 TaskStatus_t 结构体类型的数组首地址，每个任务至少需要一个TaskStatus_t 结 构 体 ， 任 务 的 数 量 可 以 使 用 函 数<span class="title function_">uxTaskGetNumberOfTasks</span><span class="params">()</span></span><br><span class="line">uxArraySize: 保存任务壮态数组的数组的大小。 </span><br><span class="line">pulTotalRunTime: 如果 configGENERATE_RUN_TIME_STATS 为 1 的话此参数用来保存系统总的运行时间。 </span><br><span class="line">返回值： 统计到的任务壮态的个数，也就是填写到数组 pxTaskStatusArray 中的个数，此值应该等于函数<span class="title function_">uxTaskGetNumberOfTasks</span><span class="params">()</span>的返回值。如果参数uxArraySize 太小的话返回值可能为0</span><br><span class="line"></span><br><span class="line">此函数用于获取系统中所有任务的任务壮态，每个任务的壮态信息保存在一个 TaskStatus_t类型的结构体里面，这个结构体里面包含了任务的任务句柄、任务名字、堆栈、优先级等信息，要使用此函数的话宏 configUSE_TRACE_FACILITY 应该定义为 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有很多就不一一列举了，小伙伴们可以自行查找相关的手册或者其他资料</p><p><img src="/img/blog/image-20220810154552622.png" alt="image-20220810154552622"></p><h3 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h3><p>创建任务一（<u>点亮LED1间隔1000MS闪烁</u> 并且 <u>串口输出传入参数</u>）</p><p>创建任务二（<u>点亮LED2间隔500MS闪烁</u>并且 <u>串口输出传入参数</u>）</p><p>创建任务三（使用KEY1删除和创建任务一）</p><p>创建任务四（使用KEY2暂停和恢复任务二）</p><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>按下KEY1，任务一被删除，再次按下新的任务一被创建</p><p>按下KEY2，任务二被暂停，再次按下任务二恢复执行</p><p><img src="/img/blog/image-20220810161620725.png" alt="image-20220810161620725"></p><h3 id="注意事项：任务被删除句柄并不会被删除，需要手动清空"><a href="#注意事项：任务被删除句柄并不会被删除，需要手动清空" class="headerlink" title="注意事项：任务被删除句柄并不会被删除，需要手动清空"></a>注意事项：任务被删除句柄并不会被删除，需要手动清空</h3>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_04</title>
      <link href="/2022/11/12/FreeRTOS-04/"/>
      <url>/2022/11/12/FreeRTOS-04/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章：任务的状态"><a href="#第四章：任务的状态" class="headerlink" title="第四章：任务的状态"></a>第四章：任务的状态</h1><p>上节课我们提了一嘴FreeRTOS当中的“阻塞模式”，然后本节课将会将这个全部展开讲述一下我们任务的其他的状态，好了话不多说，我们直接开始吧</p><h2 id="壹：状态讲解"><a href="#壹：状态讲解" class="headerlink" title="壹：状态讲解"></a><strong>壹：状态讲解</strong></h2><p>总的来说我们的状态可以分为两种，一种是运行状态，一种是非运行状态</p><h3 id="运行状态（Runing）"><a href="#运行状态（Runing）" class="headerlink" title="运行状态（Runing）"></a>运行状态（Runing）</h3><p>这个应该不需要过多的解释，它就是任务正在运行时候的这个状态被叫做运行状态</p><h3 id="非运行状态（Not-Running）"><a href="#非运行状态（Not-Running）" class="headerlink" title="非运行状态（Not Running）"></a>非运行状态（Not Running）</h3><p>这个并不只是一种运行状态而是好几种状态的统称</p><p>详细的来说它可以分为三种状态分别是：</p><p>阻塞状态(Blocked)、暂停状态(Suspended)、就绪状态(Ready)</p><h4 id="阻塞状态-Blocked-："><a href="#阻塞状态-Blocked-：" class="headerlink" title="阻塞状态(Blocked)："></a>阻塞状态(Blocked)：</h4><p>堵住了，需要等待</p><p>我们可以把执行任务当做一个那个行车的过程，我们的阻塞状态就是我们是进入了<strong>堵车</strong>的情况，然后把道路空出来，就给其它任务去执行了，这样的话我们的其他任务或者说低优先级的任务才有机会执行</p><h4 id="暂停状态-Suspended-："><a href="#暂停状态-Suspended-：" class="headerlink" title="暂停状态(Suspended)："></a>暂停状态(Suspended)：</h4><p>像这种状态一般就是将其手动设置为暂停状态，当他进入暂停状态之后就是真的暂停了，我们不解除暂停状态，他就永远不会执行</p><p>像前面一样，如果把它当做行车的过程的话，就是我们“任务小车”直接离开了车道</p><p><strong>就绪状态(Ready):</strong></p><p>这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态</p><p>像前面一样，如果我们把它当做行车的过程的话，我们的任务小车就是已经具备了行车的条件，但是由于我们的那个灯是红灯，所以还是跑不起来</p><h2 id="贰：状态之间的转换"><a href="#贰：状态之间的转换" class="headerlink" title="贰：状态之间的转换"></a><strong>贰：状态之间的转换</strong></h2><p><img src="/img/blog/image-20220809214843017.png" alt="image-20220809214843017"></p><p>这里是一张我们的那个状态转换的图表</p><h3 id="任务刚创建："><a href="#任务刚创建：" class="headerlink" title="任务刚创建："></a><strong>任务刚创建：</strong></h3><p><img src="/img/blog/image-20220809215014641.png" alt="image-20220809215014641"></p><p>我们任务刚创建的时候，就是这个小黑点，它默认是会直接进入我们的就绪状态，但是它并不会直接运行，一般是在那个调度器启动之后。才会有任务进入运行状态，因为各个任务之间要进行相互的比较和判断，谁可以先执行</p><h5 id="这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，如果同优先级的话，我们一般是后创建的那个任务会先执行"><a href="#这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，如果同优先级的话，我们一般是后创建的那个任务会先执行" class="headerlink" title="这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，如果同优先级的话，我们一般是后创建的那个任务会先执行"></a>这里提一下，我们创建完任务之后启动任务调度器默认是最高优先级的先执行，<u>如果同优先级的话，我们一般是后创建的那个任务会先执行</u></h5><h3 id="就绪状态："><a href="#就绪状态：" class="headerlink" title="就绪状态："></a><strong>就绪状态：</strong></h3><p><img src="/img/blog/image-20220809215313395.png" alt="image-20220809215313395"></p><p>我们的就绪任务状态就是我们图片中最中央的这个位置，因为通常我们的项目中任务会比较多，但是我们每次只能执行一个任务，这样的话就会有些任务，它具备了执行的条件，但是优先级抢不过其他的任务，他就是就绪状态</p><h3 id="暂停状态："><a href="#暂停状态：" class="headerlink" title="暂停状态："></a><strong>暂停状态：</strong></h3><p><img src="/img/blog/image-20220809215644619.png" alt="image-20220809215644619"></p><p>暂停状态也有人把它叫做我们的悬挂状态，这个状态是一个比较特殊的状态，就是我们直接手动给它叫停了，我们在任何状态下都可以使用对应的函数将其设置为这个暂停状态，这样的话他就永远不会被执行，直到我们将其恢复</p><p>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</p><p>其唯一的进入方法就是使用该函数进入到暂停状态</p><p>void vTaskResume( TaskHandle_t xTaskToResume );</p><p>这个是推出的函数，退出回到就绪状态</p><p>这两个函数传入的参数都是任务的句柄（后续会讲解到！）</p><h3 id="阻塞状态："><a href="#阻塞状态：" class="headerlink" title="阻塞状态："></a><strong>阻塞状态：</strong></h3><p><img src="/img/blog/image-20220809215736225.png" alt="image-20220809215736225"></p><p>这个就是我们的老朋友了，我们使用对应的有阻塞功能的函数，就可以让我们现在的任务进行短时间的阻塞，然后把我们那个任务的执行权交给已经在就绪状态的任务，让他有时间去执行</p><p>一般情况进入阻塞状态的两个函数：</p><p>voidvTaskDelay( const TickType_t xTicksToDelay ); </p><p>第1个函数它就比较简单，就非常像我们的HAL_Delay()函数。然后它里面传入的是我们的那个需要堵塞tick数,然后这个tick，就是指我们的那个节拍单位默认就是毫秒嘛，所以默认情况下它就是和我们的这个HAL_Delay是没有很大区别的，只不过还有HAL_Delay就是在空跑程序，而我们的这个是让它进入了阻塞的状态</p><p>BaseType_txTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement );</p><table><thead><tr><th>参数</th><th align="center">说明</th></tr></thead><tbody><tr><td>pxPreviousWakeTime</td><td align="center">指针，指向一个变量(指针说明这个变量即可以当做输入类型的，也可以当做输出类型的)。该变量保存任务最后一次解除阻塞的时间。第一次使用前，该变量必须初始化为当前时间。之后这个变量会在vTaskDelayUntil()函数内自动更新</td></tr><tr><td>xTimeIncrement</td><td align="center">周期循环时间。当时间等于(*pxPreviousWakeTime + xTimeIncrement)时，任务解除阻塞。如果不改变参数xTimeIncrement的值，调用该函数的任务会按照固定频率执行</td></tr></tbody></table><p>如果指定的唤醒时间已经达到，vTaskDelayUntil()立刻返回（不会有阻塞）。因此，使用vTaskDelayUntil()周期性执行的任务，无论任何原因（比如，任务临时进入挂起状态）停止了周期性执行，使得任务少运行了一个或多个执行周期，那么需要重新计算所需要的唤醒时间。这可以通过传递给函数的指针参数pxPreviousWake指向的值与当前系统时钟计数值比较来检测，在大多数情况下，这并不是必须的</p><p><strong>一般情况下，我们将第1个延时函数叫做相对时间延时，然后第2个叫做绝对时间延时</strong></p><h2 id="叁：两个延时函数的验证"><a href="#叁：两个延时函数的验证" class="headerlink" title="叁：两个延时函数的验证"></a>叁：<strong>两个延时函数的验证</strong></h2><p>然后这一小节我们将会在我们的项目中给大家验证一下，两个延时函数它的区别，带大家认识一下相对延时和绝对延时</p><h3 id="相对延时："><a href="#相对延时：" class="headerlink" title="相对延时："></a>相对延时：</h3><h4 id="是指两次任务执行的间隔时间是相对的（延时时间-x3D-任务执行时间-需要延时的时间）"><a href="#是指两次任务执行的间隔时间是相对的（延时时间-x3D-任务执行时间-需要延时的时间）" class="headerlink" title="是指两次任务执行的间隔时间是相对的（延时时间&#x3D;任务执行时间+需要延时的时间）"></a>是指两次任务执行的间隔时间是相对的（延时时间&#x3D;任务执行时间+需要延时的时间）</h4><h3 id="绝对延时："><a href="#绝对延时：" class="headerlink" title="绝对延时："></a>绝对延时：</h3><h4 id="是指两次任务执行的间隔时间是绝对的（延时时间-x3D-需要延时的时间）"><a href="#是指两次任务执行的间隔时间是绝对的（延时时间-x3D-需要延时的时间）" class="headerlink" title="是指两次任务执行的间隔时间是绝对的（延时时间&#x3D;需要延时的时间）"></a>是指两次任务执行的间隔时间是绝对的（延时时间&#x3D;需要延时的时间）</h4><h3 id="验证方法："><a href="#验证方法：" class="headerlink" title="验证方法："></a>验证方法：</h3><h4 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h4><p>Task1使用相对延时500MS，Task2使用绝对延时500MS，使用HAL_Dlay(200)模拟任务占用时间，观察现象结果</p><h4 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h4><p><img src="/img/blog/image-20220810101815557.png" alt="image-20220810101815557"></p><p>任务一延时了700ms左右，</p><p>任务二演示了较为准确的500MS</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_03</title>
      <link href="/2022/11/12/FreeRTOS-03/"/>
      <url>/2022/11/12/FreeRTOS-03/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章：FreeRTOS优先级讲解"><a href="#第三章：FreeRTOS优先级讲解" class="headerlink" title="第三章：FreeRTOS优先级讲解"></a>第三章：FreeRTOS优先级讲解</h1><p>我们的日常生活中干什么事情也会有一个轻重缓急，而我们的操作系统同样的它也会有一个轻重缓急，也就是优先级</p><p>也就是我们前面创建任务给定的优先级</p><p>​xTaskCreate(vTask1,”LED1”,128,NULL,1,NULL);</p><p>其中第五个参数，就是我们的优先级，默认情况下其范围是0~(configMAX_PRIORITIES – 1)（configMAX_PRIORITIES &#x3D;32），绝大多数情况下，他都是够用的，毕竟我们的操作系统是支持同优先级的</p><p><strong>这里提一嘴，理论上我们的FreeRTOS，如果仅通过软件层面上是可以实现无穷多个优先级的，但是这里结合了我们架构相关的东西，默认他最大只支持32级，这里大概了解一下就可以了，反正正常情况下我们是用不到那么多优先级的</strong></p><p>这里还需要和小伙伴们讲一下我们的FreeRTOS的任务执行原则</p><h2 id="壹：FreeRTOS执行任务的原则："><a href="#壹：FreeRTOS执行任务的原则：" class="headerlink" title="壹：FreeRTOS执行任务的原则："></a>壹：<strong>FreeRTOS执行任务的原则：</strong></h2><h3 id="默认情况为：使用时间片抢占式任务调度（合作式调度模式）"><a href="#默认情况为：使用时间片抢占式任务调度（合作式调度模式）" class="headerlink" title="默认情况为：使用时间片抢占式任务调度（合作式调度模式）"></a>默认情况为：<u>使用时间片抢占式任务调度</u>（合作式调度模式）</h3><h4 id="合作式任务调度解析："><a href="#合作式任务调度解析：" class="headerlink" title="合作式任务调度解析："></a>合作式任务调度解析：</h4><p>仅作了解即可，使用此种调度方式时，我们的FreeRTOS不会主动去进行任务的切换，而是当任务进行阻塞状态时，才会有那个任务的切换</p><p>合作式调度模式几乎不会用到，系统也没有相应的更新维护了</p><h4 id="抢占式任务调度解析："><a href="#抢占式任务调度解析：" class="headerlink" title="抢占式任务调度解析："></a>抢占式任务调度解析：</h4><p>各个任务执行的时候，就像我们裸机开发中的中断一样，是需要去抢这个名额，才能有机会执行，永远先执行优先级最高的任务，优先级最高的任务执行完了才有机会让低等级的任务去执行</p><h5 id="第一原则：永远先执行优先级最高的任务"><a href="#第一原则：永远先执行优先级最高的任务" class="headerlink" title="第一原则：永远先执行优先级最高的任务"></a><u><strong>第一原则：永远先执行优先级最高的任务</strong></u></h5><p>抢占式调度任务又可以分为以下两种：</p><h5 id="使用时间片的抢占式调度方法："><a href="#使用时间片的抢占式调度方法：" class="headerlink" title="使用时间片的抢占式调度方法："></a>使用时间片的抢占式调度方法：</h5><p><strong>同优先级的情况下</strong>，我们每一个时间片他都会去判断一下要不要切换任务或者说<strong>会主动去切换任务</strong></p><h5 id="不使用时间片的抢占式调度方法："><a href="#不使用时间片的抢占式调度方法：" class="headerlink" title="不使用时间片的抢占式调度方法："></a>不使用时间片的抢占式调度方法：</h5><p><strong>同优先级的情况下</strong>，将不会去判断一下要不要切换任务或者说<strong>不会主动切换任务</strong></p><h2 id="贰：FreeRTOS优先级示例分析："><a href="#贰：FreeRTOS优先级示例分析：" class="headerlink" title="贰：FreeRTOS优先级示例分析："></a>贰：<strong>FreeRTOS</strong>优先级示例分析：</h2><p>这里的示例都是默认配置下去验证的（<strong>使用时间片抢占式任务调度</strong>）并且使用的是上一章相同例程</p><h3 id="①：同优先级两个任务"><a href="#①：同优先级两个任务" class="headerlink" title="①：同优先级两个任务"></a>①：同优先级两个任务</h3><h4 id="现象：两个任务都正常运行，不会有干扰"><a href="#现象：两个任务都正常运行，不会有干扰" class="headerlink" title="现象：两个任务都正常运行，不会有干扰"></a>现象：两个任务都正常运行，不会有干扰</h4><h4 id="分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换"><a href="#分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换" class="headerlink" title="分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换"></a>分析：使用时间片抢占式任务调度的模式，同优先级情况下，每个时间片都会进行任务切换</h4><h3 id="②：LED1优先级高于LED2"><a href="#②：LED1优先级高于LED2" class="headerlink" title="②：LED1优先级高于LED2"></a>②：LED1优先级高于LED2</h3><h4 id="现象：只有LED1任务在执行，LED2任务无法正常执行"><a href="#现象：只有LED1任务在执行，LED2任务无法正常执行" class="headerlink" title="现象：只有LED1任务在执行，LED2任务无法正常执行"></a>现象：只有LED1任务在执行，LED2任务无法正常执行</h4><h4 id="分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的第一原则：永远先执行优先级最高的任务所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行"><a href="#分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的第一原则：永远先执行优先级最高的任务所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行" class="headerlink" title="分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的第一原则：永远先执行优先级最高的任务所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行"></a>分析：LED1任务的优先级高于LED2任务的优先级，我们系统运行的<u><strong>第一原则：永远先执行优先级最高的任务</strong></u>所以就把我们的LED2任务给饿死了，每个时间片都无法抢占到执行任务的机会，所以就永远无法执行</h4><h3 id="③：再②的基础上将Task1中的HAL-Delay-换为vTskDelay-osDelay"><a href="#③：再②的基础上将Task1中的HAL-Delay-换为vTskDelay-osDelay" class="headerlink" title="③：再②的基础上将Task1中的HAL_Delay()换为vTskDelay()[osDelay()]"></a>③：再②的基础上将Task1中的HAL_Delay()换为vTskDelay()[osDelay()]</h3><h4 id="现象：任务正常运行，现象和①一样"><a href="#现象：任务正常运行，现象和①一样" class="headerlink" title="现象：任务正常运行，现象和①一样"></a>现象：任务正常运行，现象和①一样</h4><h4 id="分析：vTskDelay-osDelay-有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会"><a href="#分析：vTskDelay-osDelay-有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会" class="headerlink" title="分析：vTskDelay()[osDelay()]有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会"></a>分析：vTskDelay()[osDelay()]有着某种能力使得我们的高优先级的任务停下来，然后我们低优先级的任务有执行的机会</h4><p>剧透一下，这种状态，叫做“阻塞”，顾名思义使用以后会进入一种堵车的状态，就比如说我们的vTskDelay(1000);就是堵车了一秒，这一秒钟的任务执行权力就被放开了，这样的话我们的低优先级的任务才有机会进行</p><p>好了，本期视频的内容就是这些，我们下一章节就会开始讲一下我们任务的各种状态</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_02</title>
      <link href="/2022/11/12/FreeRTOS-02/"/>
      <url>/2022/11/12/FreeRTOS-02/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：FreeRTOS的移植以及做基本的使用"><a href="#第二章：FreeRTOS的移植以及做基本的使用" class="headerlink" title="第二章：FreeRTOS的移植以及做基本的使用"></a>第二章：FreeRTOS的移植以及做基本的使用</h1><p>本节课我们将会带着大家进行我们的FreeRTOS的移植，本节课主要是实际操作，而且刚开始学习的话，暂时不用过于纠结原理，FreeRTOS只是一个使用的工具我们应该学习的是如何去使用，就像学习我们的STM32一样，先把项目建立出来，让我们LED亮起来再去研究原理和代码</p><h2 id="壹：FreeRTOS的手动移植"><a href="#壹：FreeRTOS的手动移植" class="headerlink" title="壹：FreeRTOS的手动移植"></a><strong>壹：FreeRTOS的手动移植</strong></h2><p>这里我们将会教大家 如何进行我们手动的项目移植</p><h3 id="①-建立STM32的空项目"><a href="#①-建立STM32的空项目" class="headerlink" title="①.建立STM32的空项目"></a>①.建立STM32的空项目</h3><p>这里使用STM32CubeMX快速创建项目，要注意的是我们完成最基本的配置以后，需要将我们的Timebase Source修改一下，修改成除了滴答滴答定时器的其他定时器，就像这样</p><p><img src="/img/blog/image-20220807234427467.png" alt="image-20220807234427467"></p><p>这里我使用的TIM2作为Timebase Source</p><h4 id="为什么不可以使用滴答定时器呢？"><a href="#为什么不可以使用滴答定时器呢？" class="headerlink" title="|为什么不可以使用滴答定时器呢？"></a>|<strong>为什么不可以使用滴答定时器呢？</strong></h4><p>在FreeRTOS中我们的SysTick定时器被用于了我们的始终基准，它用来实现我们的仍无切换，我们的SysTick定时器每次触发我们的中断（默认是一毫秒，可以自行修改为其他值）</p><h4 id="Timebase-Source是干嘛的呢？"><a href="#Timebase-Source是干嘛的呢？" class="headerlink" title="|Timebase Source是干嘛的呢？"></a>|Timebase Source是干嘛的呢？</h4><p>简单的说，正常裸机开发中我们的SysTick定时器是用来主要是用来进行我们的HAL_Delay()延时的，使用其作为基准，前面我们说了SysTick定时器被用于系统任务切换了，所以它就是一直在工作，或者说一直在触发中断，这样的话我们的HAL_Delay()就需用使用我们的其他定时器进行替代其作用了</p><p>为了方便移植展示，这里就生成一个Keil的项目吧！</p><h3 id="②-FreeRTOS内核下载"><a href="#②-FreeRTOS内核下载" class="headerlink" title="②.FreeRTOS内核下载"></a>②.FreeRTOS内核下载</h3><p>以我们自己的能力肯定是不可能自己写出来操作系统的，这一步将会教大家如何去下载FreeRTOS内核以及如何进行移植到我们的项目里面</p><h4 id="进入FreeRTOS的官网"><a href="#进入FreeRTOS的官网" class="headerlink" title="|进入FreeRTOS的官网"></a>|进入FreeRTOS的官网</h4><p>可以选择百度直接搜索FreeRTOS</p><p><img src="/img/blog/image-20220808155909183.png" alt="image-20220808155909183"></p><p>然后选择</p><p><img src="/img/blog/image-20220808155935717.png" alt="image-20220808155935717"></p><p>也可以直接点击该链接进入</p><p><a href="https://www.freertos.org/">https://www.freertos.org/</a></p><p>然后点击右上角下载FreeRTOS</p><p><img src="/img/blog/image-20220808160040097.png" alt="image-20220808160040097"></p><p>来到版本选择界面</p><p><img src="/img/blog/image-20220808160125937.png" alt="image-20220808160125937"></p><p>上面的是FreeRTOS的最新版本，下面的就是长期维护的版本</p><p>我们直接点击上面这个Github的超链接</p><p><img src="/img/blog/image-20220808161616625.png" alt="image-20220808161616625"></p><p>然后就依次带点击Code和Download ZIP</p><p><img src="/img/blog/image-20220808161844246.png" alt="image-20220808161844246"></p><p>不过我发现，这个下载下来好像是不完整的</p><p><img src="/img/blog/image-20220808161954743.png" alt="image-20220808161954743"></p><p>这里也写了它的子模块是不会直接下载进去的，这里我们就需要继续往下翻</p><p><img src="/img/blog/image-20220808162132172.png" alt="image-20220808162132172"></p><p>翻译过来就是这样的</p><p><img src="/img/blog/image-20220808162148237.png" alt="image-20220808162148237"></p><p>内核代码在这里我们点击超链接，同样的方法进行下载</p><p>这里就快速掠过，如果无法下载应该就是网络问题了</p><p>下载好，然后进行一下解压</p><p><img src="/img/blog/image-20220808174843292.png" alt="image-20220808174843292"></p><p>解压好了就是这个样子</p><p>FreeRTOS-Kernel是FreeRTOS的内核文件</p><p>FreeRTOS-main里面文件很多，我们主要是看里面的Demo</p><p><img src="/img/blog/image-20220808175037048.png" alt="image-20220808175037048"></p><p>然后接着点击<img src="/img/blog/image-20220808175057051.png" alt="image-20220808175057051"></p><p>里面的文件非常多，不过我们可以找到这样一个文件夹</p><p><img src="/img/blog/image-20220808175154467.png" alt="image-20220808175154467"></p><p>这里有系统已经移植好的实例，但是这并不是我们直接移植的，感兴趣的小伙伴可以先打看官方移植好的能不能看懂</p><h3 id="③-手动移植FreeRTOS内核文件"><a href="#③-手动移植FreeRTOS内核文件" class="headerlink" title="③.手动移植FreeRTOS内核文件"></a>③.手动移植FreeRTOS内核文件</h3><h4 id="1-打开第一步建立的新项目"><a href="#1-打开第一步建立的新项目" class="headerlink" title="1.打开第一步建立的新项目"></a>1.打开第一步建立的新项目</h4><h4 id="2-左侧项目文件添加两个新的分组"><a href="#2-左侧项目文件添加两个新的分组" class="headerlink" title="2.左侧项目文件添加两个新的分组"></a>2.左侧项目文件添加两个新的分组</h4><p><img src="/img/blog/image-20220808180601576.png" alt="image-20220808180601576"></p><h4 id="3-建立对应的FreeRTOS文件夹"><a href="#3-建立对应的FreeRTOS文件夹" class="headerlink" title="3.建立对应的FreeRTOS文件夹"></a>3.建立对应的FreeRTOS文件夹</h4><p><img src="/img/blog/image-20220808181508665.png" alt="image-20220808181508665"></p><h4 id="4-打开FreeRTOS-Kernel文件夹"><a href="#4-打开FreeRTOS-Kernel文件夹" class="headerlink" title="4.打开FreeRTOS-Kernel文件夹"></a>4.打开FreeRTOS-Kernel文件夹</h4><h4 id="5-主目录下所有的-C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）"><a href="#5-主目录下所有的-C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）" class="headerlink" title="5.主目录下所有的.C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）"></a>5.主目录下所有的.C后缀的文件全部复制我们的FreeRTOS文件夹下（一共七个）</h4><p><img src="/img/blog/image-20220808181613953.png" alt="image-20220808181613953"></p><h4 id="6-复制include文件夹以及portable文件夹到FreeRTOS文件夹下"><a href="#6-复制include文件夹以及portable文件夹到FreeRTOS文件夹下" class="headerlink" title="6.复制include文件夹以及portable文件夹到FreeRTOS文件夹下"></a>6.复制include文件夹以及portable文件夹到FreeRTOS文件夹下</h4><p><img src="/img/blog/image-20220808181838922.png" alt="image-20220808181838922"></p><h4 id="7-保留FreeRTOS-x2F-portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除"><a href="#7-保留FreeRTOS-x2F-portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除" class="headerlink" title="7.保留FreeRTOS&#x2F;portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除"></a>7.保留FreeRTOS&#x2F;portable文件夹中的Keil、MemMang、RVDS文件夹，其余全部删除</h4><p><img src="/img/blog/image-20220808182219502.png" alt="image-20220808182219502"></p><h4 id="8-保留FreeRTOS-x2F-portable-x2F-RVDS文件夹中的ARM-CM3文件夹"><a href="#8-保留FreeRTOS-x2F-portable-x2F-RVDS文件夹中的ARM-CM3文件夹" class="headerlink" title="8.保留FreeRTOS&#x2F;portable&#x2F;RVDS文件夹中的ARM_CM3文件夹"></a>8.保留FreeRTOS&#x2F;portable&#x2F;RVDS文件夹中的ARM_CM3文件夹</h4><p><img src="/img/blog/image-20220808182339598.png" alt="image-20220808182339598"></p><h4 id="9-然后如图进行Keil项目的分组文件配置"><a href="#9-然后如图进行Keil项目的分组文件配置" class="headerlink" title="9.然后如图进行Keil项目的分组文件配置"></a>9.然后如图进行Keil项目的分组文件配置</h4><p><img src="/img/blog/image-20220808182506735.png" alt="image-20220808182506735"></p><p><img src="/img/blog/image-20220808182619420.png" alt="image-20220808182619420"></p><h4 id="10-添加对应的头文件"><a href="#10-添加对应的头文件" class="headerlink" title="10.添加对应的头文件"></a>10.添加对应的头文件</h4><p><img src="/img/blog/image-20220808182744742.png" alt="image-20220808182744742"></p><h4 id="11-直接编译（出现9个错误）"><a href="#11-直接编译（出现9个错误）" class="headerlink" title="11.直接编译（出现9个错误）"></a>11.直接编译（出现9个错误）</h4><p><img src="/img/blog/image-20220808183013851.png" alt="image-20220808183013851"></p><h3 id="④-项目问题修复"><a href="#④-项目问题修复" class="headerlink" title="④.项目问题修复"></a>④.项目问题修复</h3><h4 id="缺少FreeRTOSConfig-h文件（FreeRTOS的配置文件）"><a href="#缺少FreeRTOSConfig-h文件（FreeRTOS的配置文件）" class="headerlink" title="|缺少FreeRTOSConfig.h文件（FreeRTOS的配置文件）"></a>|缺少FreeRTOSConfig.h文件（FreeRTOS的配置文件）</h4><p><img src="/img/blog/image-20220808183724419.png" alt="image-20220808183724419"></p><h4 id="示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）"><a href="#示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）" class="headerlink" title="|示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）"></a>|示例项目中复制粘贴并且添加到项目文件夹中（记得添加头文件路径）</h4><p><img src="/img/blog/image-20220808183808327.png" alt="image-20220808183808327"></p><p><img src="/img/blog/image-20220808183927543.png" alt="image-20220808183927543"></p><h4 id="编译，还是报错"><a href="#编译，还是报错" class="headerlink" title="|编译，还是报错"></a>|编译，还是报错</h4><p><img src="/img/blog/image-20220808184017777.png" alt="image-20220808184017777"></p><h4 id="在FreeRTOSConfig-h中添加-defineINCLUDE-xTaskGetCurrentTaskHandle1"><a href="#在FreeRTOSConfig-h中添加-defineINCLUDE-xTaskGetCurrentTaskHandle1" class="headerlink" title="|在FreeRTOSConfig.h中添加#defineINCLUDE_xTaskGetCurrentTaskHandle1"></a>|在FreeRTOSConfig.h中添加#defineINCLUDE_xTaskGetCurrentTaskHandle1</h4><h4 id="编译无错误"><a href="#编译无错误" class="headerlink" title="|编译无错误"></a>|编译无错误</h4><p><img src="/img/blog/image-20220808191109640.png" alt="image-20220808191109640"></p><h3 id="⑤-项目添加处理"><a href="#⑤-项目添加处理" class="headerlink" title="⑤.项目添加处理"></a>⑤.项目添加处理</h3><p>虽然没有错误了，但是我们的移植没有完成，还有一些小步骤需要完成，的确有些繁琐，好在逻辑性还是比较强的，理解起来相对容易</p><h4 id="在FreeRTOSConfig-h中添加-definexPortPendSVHandlerPendSV-Handler"><a href="#在FreeRTOSConfig-h中添加-definexPortPendSVHandlerPendSV-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definexPortPendSVHandlerPendSV_Handler"></a>|在FreeRTOSConfig.h中添加#definexPortPendSVHandlerPendSV_Handler</h4><h4 id="在FreeRTOSConfig-h中添加-definexPortSysTickHandlerSysTick-Handler"><a href="#在FreeRTOSConfig-h中添加-definexPortSysTickHandlerSysTick-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definexPortSysTickHandlerSysTick_Handler"></a>|在FreeRTOSConfig.h中添加#definexPortSysTickHandlerSysTick_Handler</h4><h4 id="在FreeRTOSConfig-h中添加-definevPortSVCHandlerSVC-Handler"><a href="#在FreeRTOSConfig-h中添加-definevPortSVCHandlerSVC-Handler" class="headerlink" title="|在FreeRTOSConfig.h中添加#definevPortSVCHandlerSVC_Handler"></a>|在FreeRTOSConfig.h中添加#definevPortSVCHandlerSVC_Handler</h4><p>左边三个是我们Free RTOS中定义好的函数，右边的是系统项目本来就定义好的函数，他们的作用小伙伴们可以去了解一下，作为初学者这里不进行拓展，反正就是和我们操作系统的中断还有任务切换有关的函数</p><h4 id="编译，还是报错，重复定义"><a href="#编译，还是报错，重复定义" class="headerlink" title="|编译，还是报错，重复定义"></a>|编译，还是报错，重复定义</h4><p><img src="/img/blog/image-20220808193114683.png" alt="image-20220808193114683"></p><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="|处理错误"></a>|处理错误</h4><h4 id="进入对应的文件stm32f1xx-it-c删除重复的3个函数"><a href="#进入对应的文件stm32f1xx-it-c删除重复的3个函数" class="headerlink" title="|进入对应的文件stm32f1xx_it.c删除重复的3个函数"></a>|进入对应的文件stm32f1xx_it.c删除重复的3个函数</h4><h4 id="OK啦！"><a href="#OK啦！" class="headerlink" title="|OK啦！"></a>|OK啦！</h4><h3 id="⑥-FreeRTOS点灯项目创建"><a href="#⑥-FreeRTOS点灯项目创建" class="headerlink" title="⑥.FreeRTOS点灯项目创建"></a>⑥.FreeRTOS点灯项目创建</h3><p>弄了这么久，终于移植完成了，我们现在开始创建我们的任务吧！</p><p>首先回到项目中我们需要</p><h4 id="相关的头文件引入"><a href="#相关的头文件引入" class="headerlink" title="相关的头文件引入"></a><strong>相关的头文件引入</strong></h4><p>用到的头文件有<br>“FreeRTOS.h”（操作系统相关）</p><p>“task.h”（任务相关）</p><p><img src="/img/blog/image-20220808205027644.png" alt="image-20220808205027644"></p><h4 id="任务函数创建"><a href="#任务函数创建" class="headerlink" title="任务函数创建"></a><strong>任务函数创建</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,<span class="number">0</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,<span class="number">1</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,<span class="number">0</span>);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,<span class="number">1</span>);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主函数创建任务，以及开启任务调度器"><a href="#主函数创建任务，以及开启任务调度器" class="headerlink" title="主函数创建任务，以及开启任务调度器"></a><strong>主函数创建任务，以及开启任务调度器</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    <span class="comment">//创建任务1</span></span><br><span class="line">xTaskCreate(vTask1,<span class="string">&quot;LED1&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建任务2</span></span><br><span class="line">xTaskCreate(vTask2,<span class="string">&quot;LED2&quot;</span>,<span class="number">128</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//启动任务调度器</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦-程序烧录到开发板查看效果"><a href="#⑦-程序烧录到开发板查看效果" class="headerlink" title="⑦.程序烧录到开发板查看效果"></a>⑦.程序烧录到开发板查看效果</h3><p>编译项目，然后进行简单的烧录，并且查看效果</p><h2 id="贰：CubeMX快速生成FreeRTOS项目"><a href="#贰：CubeMX快速生成FreeRTOS项目" class="headerlink" title="贰：CubeMX快速生成FreeRTOS项目"></a><strong>贰：CubeMX快速生成FreeRTOS项目</strong></h2><p>前面我们已经成功手动移植了我们的FreeRTOS的操作系统，步骤相对来说还是比较繁琐的，在我们的开发中肯定不可能每次都去这样的移植，所以我们本期视频就是教大家一个更快捷高效的方法，也就是使用我们的CubeMX快速生产FreeRTOS的项目，并且达到我们上期视频同样的效果，好了我们现在开始，这里我将会使用CubeIDE来生成项目</p><h3 id="①正常流程初始化项目"><a href="#①正常流程初始化项目" class="headerlink" title="①正常流程初始化项目"></a>①正常流程初始化项目</h3><p>我们就按照平常初始化项目，把我们的时钟频率设置好以及我们上节课讲到了基本时钟源改为其他的定时器</p><p><img src="/img/blog/image-20220809090154611.png" alt="image-20220809090154611"></p><p><img src="/img/blog/image-20220809090213133.png" alt="image-20220809090213133"></p><h3 id="②找到Middleware选项然后点击FREERTOS"><a href="#②找到Middleware选项然后点击FREERTOS" class="headerlink" title="②找到Middleware选项然后点击FREERTOS"></a>②找到Middleware选项然后点击FREERTOS</h3><p><img src="/img/blog/image-20220809090351242.png" alt="image-20220809090351242"></p><h3 id="③选择CMSIS-V1"><a href="#③选择CMSIS-V1" class="headerlink" title="③选择CMSIS_V1"></a>③选择CMSIS_V1</h3><h4 id="版本解释"><a href="#版本解释" class="headerlink" title="版本解释"></a>版本解释</h4><p>V1的这个版本是老版本，然后V2版本是新版本，其实区别没有很大版本也没有差很多，不过相对来说我们直接选择V1就可以了，因为使用的人是比较多的</p><h3 id="④参数介绍"><a href="#④参数介绍" class="headerlink" title="④参数介绍"></a>④参数介绍</h3><p><img src="/img/blog/image-20220809090701721.png" alt="image-20220809090701721"></p><p>可以看到我们需要设置的参数是非常非常多的，这里阿熊就给大家简单的解释一些常用的后续碰到会陆续的进行解释</p><h4 id="Config-parameters（配置参数）"><a href="#Config-parameters（配置参数）" class="headerlink" title="Config parameters（配置参数）"></a>Config parameters（配置参数）</h4><p><img src="/img/blog/image-20220809090918763.png" alt="image-20220809090918763"></p><p>这里就是我们Free RTOS的配置参数，可以选择性的开启或者关闭某些功能，我们前面有讲过FreeRTOS的可裁剪性，是它的一大优势，像我们的这些设置里就是开启或关闭它的一些功能</p><h4 id="Include-parameters（内部参数）"><a href="#Include-parameters（内部参数）" class="headerlink" title="Include parameters（内部参数）"></a>Include parameters（内部参数）</h4><p><img src="/img/blog/image-20220809091219415.png" alt="image-20220809091219415"></p><p>这里面是我们开发中可能会用到的一些函数，我们如果用不到的话可以就选择性的将其关闭，这样的话我们的内核大小也会减小很多</p><h4 id="Tasks-and-Queues（任务和队列）"><a href="#Tasks-and-Queues（任务和队列）" class="headerlink" title="Tasks and Queues（任务和队列）"></a>Tasks and Queues（任务和队列）</h4><p><img src="/img/blog/image-20220809091405056.png" alt="image-20220809091405056"></p><p>我们操作系统中的任务还有我们的队列（后续会介绍到）都是可以直接在这里进行一个初始化的，我们只需要去更新内部的函数内容就可以高效的完成我们的项目</p><h4 id="Other（其他设置）"><a href="#Other（其他设置）" class="headerlink" title="Other（其他设置）"></a>Other（其他设置）</h4><p>这里我们就只介绍我们的这3个比较重要的，其他的全部统称为其他设置，后续的课程中，我们遇到了再讲解</p><h3 id="⑤添加Task"><a href="#⑤添加Task" class="headerlink" title="⑤添加Task"></a>⑤添加Task</h3><p>直接点击Add或者双击默认的项目</p><p><img src="/img/blog/image-20220809091752257.png" alt="image-20220809091752257"></p><p>其分别对应</p><p>任务名称、任务优先级、任务堆栈大小、进入函数名称、代码生成方式、参数、任务类型</p><h4 id="任务名称："><a href="#任务名称：" class="headerlink" title="任务名称："></a>任务名称：</h4><p>就是单纯的名称，一般随便取一个就好了，没有什么实质性的作用，毕竟我们执行的时候用的是函数名称</p><h4 id="任务优先级："><a href="#任务优先级：" class="headerlink" title="任务优先级："></a>任务优先级：</h4><p>任务优先级就很像我们那个中断优先级，不过它与我们的中断优先级是相反的，我们的中断优先级中的中段是数字越小，然后它的优先级就会越高，我们的操作系统中数字越大，优先级越高，并且会优先执行</p><h4 id="任务堆栈大小："><a href="#任务堆栈大小：" class="headerlink" title="任务堆栈大小："></a>任务堆栈大小：</h4><p>就是可以理解为我们的任务执行所需要的空间大小，太大了不是很好，太小了反而会不够，所以这个需要一定的经验去判断</p><h4 id="进入函数名称："><a href="#进入函数名称：" class="headerlink" title="进入函数名称："></a>进入函数名称：</h4><p>就是我们执行任务时对应的那个函数，它的名称是什么？我们的系统会自动给我们写好一个框架</p><h4 id="任务类型："><a href="#任务类型：" class="headerlink" title="任务类型："></a>任务类型：</h4><p>我们任务生成的类型有动态生成，还有静态生成，动态生成的话就是系统，你只要告诉他空间大小系统会自己划分好，而我们静态生成是直接要指定一块地点，相对来说使用是非常少的，而且作为初学者几乎是完全理解不了的，所以我们本视频系列教程是不会涉及到静态生成任务，只会讲解动态任务</p><h4 id="Other："><a href="#Other：" class="headerlink" title="Other："></a>Other：</h4><p>前面就是我们需要理解的，其他的我们后续遇到了会再讲解</p><h4 id="添加LED的任务："><a href="#添加LED的任务：" class="headerlink" title="添加LED的任务："></a>添加LED的任务：</h4><p><img src="/img/blog/image-20220809092814718.png" alt="image-20220809092814718"></p><p><img src="/img/blog/image-20220809092900372.png" alt="image-20220809092900372"></p><h4 id="保存一下，然后生成项目"><a href="#保存一下，然后生成项目" class="headerlink" title="保存一下，然后生成项目"></a>保存一下，然后生成项目</h4><h3 id="⑥完成任务函数"><a href="#⑥完成任务函数" class="headerlink" title="⑥完成任务函数"></a>⑥完成任务函数</h3><p>可以看到我们生成的项目中，main.C中他并没有那个任务的函数，我们可以找到左边的那个文件管理来，可以找到一个freeRTOS.C的项目文件，然后我们双击打开</p><p><img src="/img/blog/image-20220809093230591.png" alt="image-20220809093230591"></p><p>然后我们就可以快速的完成一下两个任务，上节课视频我们也有讲过，如何去书写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header_LED_Task1 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Function implementing the LED1 thread.</span></span><br><span class="line"><span class="comment">  * @param  argument: Not used</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_LED_Task1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED_Task1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,<span class="number">1</span>);</span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin,<span class="number">0</span>);</span><br><span class="line">  HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED_Task1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Header_LED_Task2 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Function implementing the LED2 thread.</span></span><br><span class="line"><span class="comment">* @param argument: Not used</span></span><br><span class="line"><span class="comment">* @retval None</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_LED_Task2 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED_Task2 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin,<span class="number">1</span>);</span><br><span class="line">  HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin,<span class="number">0</span>);</span><br><span class="line">  HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED_Task2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦编译，烧录查看现象"><a href="#⑦编译，烧录查看现象" class="headerlink" title="⑦编译，烧录查看现象"></a>⑦编译，烧录查看现象</h3><p>可以看到我们的那个实验现象和上期手动移植的现象是完全一样的，我们成功完成了快速生成FreeRTOS的项目并且完成了最基本的任务</p><h3 id="⑧代码讲解"><a href="#⑧代码讲解" class="headerlink" title="⑧代码讲解"></a>⑧代码讲解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* Call init function for freertos objects (in freertos.c) */</span></span><br><span class="line">  MX_FREERTOS_Init();</span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="comment">/* We should never get here as control is now taken by the scheduler */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数中，我们最开始还是普通的初始化，和我们的普通项目没有区别</p><p>接着是</p><p>MX_FREERTOS_Init();</p><p>我们转跳过去看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Create the thread(s) */</span></span><br><span class="line">  <span class="comment">/* definition and creation of LED1 */</span></span><br><span class="line">  osThreadDef(LED1, LED_Task1, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED1Handle = osThreadCreate(osThread(LED1), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* definition and creation of LED2 */</span></span><br><span class="line">  osThreadDef(LED2, LED_Task2, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED2Handle = osThreadCreate(osThread(LED2), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容也很简单，其实他就是创建了我们的两个项目，然后相对来说小伙伴们可以发现和我们手动一直是不一样的，因为我们的 Free rtos的那个操作系统在我们那个ST官方的那个优化下，他自己将很多函数都进行了重新的宏定义以及方法的改写</p><p>我们甚至可以转跳过去看看他是怎么实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">osThreadId <span class="title function_">osThreadCreate</span> <span class="params">(<span class="type">const</span> osThreadDef_t *thread_def, <span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TaskHandle_t handle;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line">  <span class="keyword">if</span>((thread_def-&gt;buffer != <span class="literal">NULL</span>) &amp;&amp; (thread_def-&gt;controlblock != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              thread_def-&gt;buffer, thread_def-&gt;controlblock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              &amp;handle) != pdPASS)  &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span>( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line"></span><br><span class="line">    handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">              thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">              thread_def-&gt;buffer, thread_def-&gt;controlblock);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_def-&gt;name,</span><br><span class="line">                   thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span><br><span class="line">                   &amp;handle) != pdPASS)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然他看起来很复杂，但是我们几乎可以一眼就找到我们上节课用到的那个xTaskCreate函数</p><p>在我们系统生成的FreeRTOS的框架下，它是宏定义了很多的函数，但其实用法师和我们的没有什么区别，我们甚至可以直接用我们上节课所写的那些东西,也可以实现同样的效果</p><p>这里就不拓展开了，碰到了我们再讲解</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS_01</title>
      <link href="/2022/11/12/FreeRTOS-01/"/>
      <url>/2022/11/12/FreeRTOS-01/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：FreeRTOS的简述"><a href="#第一章：FreeRTOS的简述" class="headerlink" title="第一章：FreeRTOS的简述"></a>第一章：FreeRTOS的简述</h1><p>说到FreeRTOS，就不得不先带着大家去了解一下我们的RTOS</p><h2 id="壹：RTOS的简介"><a href="#壹：RTOS的简介" class="headerlink" title="壹：RTOS的简介"></a><strong>壹：RTOS的简介</strong></h2><p>实时操作系统（Real Time Operating System，简称RTOS）是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点</p><p><a href="https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/357530?fromtitle=RTOS&amp;fromid=987080&amp;fr=aladdin">https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/357530?fromtitle=RTOS&amp;fromid=987080&amp;fr=aladdin</a></p><p>这里有转跳链接，小伙伴们可以转跳过去仔细看看，这里就不过多的赘述，简单的总结如下：</p><p>大体上，实时操作系统（RTOS）要求：</p><ul><li>多任务</li><li>处理能被区分优先次序的进程线</li><li>一个中断水平的充分数量</li></ul><p>被装入作为微型设备一部分的内含小操作系统经常要求实时操作系统。一些核心问题能被考虑以符合实时操作系统的需求。然而，因为像设备驱动程序这样的其他成份，也通常被特别的方法需要，一个实时操作系统通常比核心更大</p><p>RTOS只是一个统称，他可以分为各种各样的版本以及平台，由于RTOS需占用一定的系统资源(尤其是RAM资源)，只有μC&#x2F;OS-II、embOS、salvo、FreeRTOS等少数能在小RAM单片机上运行。相对μC&#x2F;OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，具有源码公开、可移植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行</p><p>然后我们现在来看我们的FreeRTOS</p><h2 id="贰：FreeRTOS的简介"><a href="#贰：FreeRTOS的简介" class="headerlink" title="贰：FreeRTOS的简介"></a><strong>贰：FreeRTOS的简介</strong></h2><p>FreeRTOS是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要</p><p>其功能特点如下：</p><ul><li><strong>用户可配置内核功能(可裁剪)</strong></li><li><strong>多平台的支持</strong></li><li><strong>提供一个高层次的信任代码的完整性</strong></li><li><strong>目标代码小，简单易用</strong></li><li><strong>遵循MISRA-C标准的编程规范</strong></li><li><strong>强大的执行跟踪功能</strong></li><li><strong>堆栈溢出检测</strong></li><li><strong>没有限制的任务数量</strong></li><li><strong>没有限制的任务优先级</strong></li><li><strong>多个任务可以分配相同的优先权</strong></li><li><strong>队列，二进制信号量，计数信号灯和递归通信和同步的任务</strong></li><li><strong>优先级继承</strong></li><li><strong>免费开源的源代码</strong></li></ul><p>并且最重要的一点是支持免费的商用，而且社区环境很好，使用的人很多</p><p><strong>这里有转跳链接，小伙伴们可以转跳过去仔细看看</strong></p><p><a href="https://baike.baidu.com/item/FreeRTOS/9786143?fr=aladdin">https://baike.baidu.com/item/FreeRTOS/9786143?fr=aladdin</a></p><h2 id="叁：多任务操作系统的引入"><a href="#叁：多任务操作系统的引入" class="headerlink" title="叁：多任务操作系统的引入"></a>叁：多任务操作系统的引入</h2><p>说到多任务操作系统，我们就不得不提到我们的裸机开发，裸机开发的话，它并不是相对于多任务操作系统就很弱，他们俩在各自的领域有各自的使用场景，也有各自的优缺点，就比如说我们直接进行裸机开发，它主要是在我们的一个while循环中进行所有的项目操作，有些情况下，会有一个或者多个中断来处理一些突然发生的事或者已经设计好的事情，如果我们仅仅是开发一些小项目或者功能比较单一的项目，裸机是最可靠最有效而且很方便开发的一种模式，但是当我们的项目功能越来越多，我们就要引入多任务的操作系统，多任务操作系统顾名思义就是可以处理很多个任务，就像我们的手机一样，我们的手机后台也是可以挂起多个应用的</p><p>在我们引入操作系统之后，我们就不需要去精心的设计我们的时序流程，因为各个任务之间是不存在相互干扰的，我们只需要使用我们的命令去开启或者关闭某一些任务就可以了，当然这肯定是需要占用一些系统资源的，不过现在的单片机的内存都是足够大的，所以我们一般情况下是不需要担心我们的操作系统内核，而是直接移植进行使用，并且我们的多任务操作系统的思维，就很像我们人去思考的思维更加的方便，而我们的裸机开发更像是机械思维，在开发过程中以及开发流程中操作系统是非常方便使用以及开发的</p><p>我们可以再通俗一点的讲，把我们的单片机当做一台电脑的CPU，就像我们使用的电脑一样，我们在上面安装了windows系统，而我们需要执行的任务，比如说打开QQ或者其他的任务，只需要在操作系统上进行完成就可以了</p><p>说了这么多，相信小伙伴们还是对实际的多任务操作系统还是没什么概念，这里就简单给大家举一个例子</p><p>这里并不会出现源码，只是大概的体现一下RTOS与裸机开发的不同之处</p><p>裸机开发中LED闪烁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    whlie(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LED1置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED1置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是只有一个LED的情况如果有两个LED，一个需要500MS闪烁，一个需要一秒闪烁一次，这样的话我们的代码是不是难度就加大了,好像逻辑就混乱了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    whlie(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LED1置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED1置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时1000MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED2置为高电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时500MS</span></span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">//LED置为低电平</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//延时500MS</span></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们大脑最希望的添加代码方式，很显然他是错的，两个任务之间产生了相互的影响，使得两个任务都执行错误，很多同学就会说这是阿熊代码的问题，对没错，这种思想在裸机开发中肯定是错的，但是在我们的RTOS中他就可以是对的</p><p><img src="/img/blog/image-20220807151229878.png" alt="1"></p><p>这是我们独立的两个任务内容，我们只需要把他的扔到我们的任务执行器里，他就会“同时”运行了，很多小伙伴就会疑问了，单片机明明只有一个核，为什么可以同时执行多个任务呢？</p><h2 id="肆：任务“同时”执行的原理"><a href="#肆：任务“同时”执行的原理" class="headerlink" title="肆：任务“同时”执行的原理"></a>肆：任务“同时”执行的原理</h2><p>还记得我们51单片机里面讲的8*8LED的点阵吗？</p><p><img src="/img/blog/image-20220807151850554.png" alt="2">)</p><p>就这家伙，还记得他是怎么做到使用16个引脚驱动64个灯的吗？</p><p>视觉暂停，也可以说是“视觉欺骗”，他并不是同时亮起来的，而是一排一排亮起来的，只不过切换的速度太快了，肉眼反应不过来，所以就同时亮起来了</p><p>我们RTOS也差不多是这样，我们可以让我们的每个任务执行一个时间单位，然后就切换到另外一个任务执行一个时间单位，再切换回去，两个任务都是独立运行的，互不影响，由于切换的频率很快，就感觉像是同时运行的一样</p><p><img src="/img/blog/image-20220807161019652.png" alt="3"></p><h1 id="这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮"><a href="#这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮" class="headerlink" title="这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮"></a>这是一个简单的示意图，小伙伴们试着理解一下，我们本章的内容就是这些，下节课开始我们将会教小伙伴们如何进行我们操作系统的移植并且让我们的LED可分别点亮</h1><hr>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
